{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gps_time","text":"<p>GPS Time representation and tools for Python.</p>"},{"location":"#breaking-change","title":"Breaking Change","text":"<p>Prior to version 3.x, <code>gps_time</code> did not include any timezone information, i.e.\u00a0all datetimes used by <code>gps_time</code> were \u201cnaive\u201d. This could lead to errors for versions of python that default to \u201caware\u201d datetime objects. In version 3, <code>gps_time</code> is updated to function using aware datetime objects. If you pass <code>gps_time</code> a naive datetime, it will assume that it is meant to represent UTC time. As this was the expected behavior, there should be minimal impact, but this may result in errors to existing code bases.</p>"},{"location":"#install","title":"Install","text":"<p>Installation can be achieved using <code>pip</code>, specifically</p> <pre><code>pip install gps_time\n</code></pre>"},{"location":"#how-to-use","title":"How to use","text":"<p>This module is relatively straightfoward to use. The <code>GPSTime</code> objects are generated (using arbitrary numbers) by</p> <pre><code>from gps_time import GPSTime\ngps_time1 = GPSTime(week_number=1872, time_of_week=3324.654324324234324)\ngps_time2 = GPSTime(week_number=1875, time_of_week=9890874.32)\n</code></pre> <pre><code>2\n</code></pre> <p>Notice that the time of week for <code>gps_time2</code> is longer than a week. The <code>GPSTime</code> object will automatically adjust the week number and time of week to reasonable values.</p> <pre><code>print(gps_time2)\n</code></pre>"},{"location":"#conversion","title":"Conversion","text":"<p>The <code>GPSTime</code> objects can also created from <code>datetime.datetime</code> objects</p> <pre><code>import datetime\ngps_time3 = GPSTime.from_datetime(datetime.datetime(2017, 9, 2, 13, 23, 12, 211423))\nprint(gps_time3)\n</code></pre> <p><code>GPSTime</code> can likewise be converted to <code>datetime.datetime</code> object. However, one must be careful because <code>datetime.datetime</code> objects only preserve microsecond resolution. Converting from <code>GPSTime</code> to <code>datetime.datetime</code> can lose information. The opposite conversion does not lose information.</p> <pre><code>print(f\"GPS Time: {gps_time1}\")\nprint(f\"Datetime: {gps_time1.to_datetime()}\")\nprint(\"\")\nprint(f\"Lost Precision: {gps_time1 - GPSTime.from_datetime(gps_time1.to_datetime())}\")\n</code></pre>"},{"location":"#operators","title":"Operators","text":"<p><code>GPSTime</code> has comparison operators defined (equality, less than, etc.). It also has addition and subtraction defined. In general, one can add/subtract either <code>float</code>s or other <code>GPSTime</code>s.</p> <p>For floats, it is interpreted as a time shift in seconds (forward for addition, backward for subtraction). This operation accounts for the time of week. In-place addition and subtraction, i.e.\u00a0the <code>+=</code> and <code>-=</code> operators are supported for floats.</p> <pre><code>time_shift_seconds = 23431123.3243\n\nprint(f\"Addition (float):    {gps_time2 + time_shift_seconds}\")\nprint(f\"Subtraction (float): {gps_time2 - time_shift_seconds}\")\n</code></pre> <p>Alternatively, addition and subtraction can be done using two <code>GPSTime</code> objects. Subtraction finds the time difference in seconds (as a float). Addition essentially sums the week numbers and times of week. Notice that in-place addition and subtraction are not supported for two <code>GPSTime</code> objects.</p> <pre><code>print(f\"Addition (GPSTime):    {gps_time2 + gps_time1}\")\nprint(f\"Subtraction (GPSTime): {gps_time2 - gps_time1}\")\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Copyright (2020) The Aerospace Corporation. All Rights Reserved</p> <p>The <code>gps_time</code> module releasded under the Apache2 license.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":""},{"location":"CONTRIBUTING/#how-to-get-started","title":"How to get started","text":"<p>Before anything else, please clone the repository and install the development dependencies. This will allow you to run tests and build the documentation locally.</p> <ol> <li>Clone the repository.</li> <li>Create a virtual environment: <code>python -m venv .venv</code> and activate it.</li> <li>Install development dependencies: <code>pip install -e .[dev]</code></li> </ol>"},{"location":"CONTRIBUTING/#did-you-find-a-bug","title":"Did you find a bug?","text":"<ul> <li>Ensure the bug was not already reported by searching on GitHub under Issues.</li> <li>If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.</li> <li>Be sure to add the complete error messages.</li> </ul>"},{"location":"CONTRIBUTING/#did-you-write-a-patch-that-fixes-a-bug","title":"Did you write a patch that fixes a bug?","text":"<ul> <li>Open a new GitHub pull request with the patch.</li> <li>Ensure that your PR includes a test that fails without your patch, and pass with it.</li> <li>Ensure the PR description clearly describes the problem and solution. Include the relevant issue number if applicable.</li> </ul>"},{"location":"CONTRIBUTING/#pr-submission-guidelines","title":"PR submission guidelines","text":"<ul> <li>Keep each PR focused. While it's more convenient, do not combine several unrelated fixes together. Create as many branches as needing to keep each PR focused.</li> <li>Do not mix style changes/fixes with \"functional\" changes. It's very difficult to review such PRs and it most likely get rejected.</li> <li>Do not add/remove vertical whitespace. Preserve the original style of the file you edit as much as you can.</li> <li>Do not turn an already submitted PR into your development playground. If after you submitted PR, you discovered that more work is needed - close the PR, do the required work and then submit a new PR. Otherwise each of your commits requires attention from maintainers of the project.</li> <li>If, however, you submitted a PR and received a request for changes, you should proceed with commits inside that PR, so that the maintainer can see the incremental fixes and won't need to review the whole PR again. In the exception case where you realize it'll take many many commits to complete the requests, then it's probably best to close the PR, do the work and then submit it again. Use common sense where you'd choose one way over another.</li> </ul>"},{"location":"CONTRIBUTING/#do-you-want-to-contribute-to-the-documentation","title":"Do you want to contribute to the documentation?","text":"<ul> <li>Docs are built using <code>mkdocs</code>. You can serve them locally with <code>mkdocs serve</code>.</li> <li>The documentation source files are located in the <code>docs/</code> directory.</li> </ul>"},{"location":"advanced_examples/","title":"Advanced Examples","text":"<p>This page demonstrates scenarios where <code>GPSTime</code> provides critical advantages over standard Python <code>datetime</code> objects, specifically regarding precision and physical time intervals.</p>"},{"location":"advanced_examples/#1-sub-microsecond-precision","title":"1. Sub-Microsecond Precision","text":"<p>Standard <code>datetime</code> objects are limited to microsecond (\\(10^{-6}\\)) precision. <code>GPSTime</code> supports femtosecond (\\(10^{-15}\\)) precision.</p>"},{"location":"advanced_examples/#the-problem-with-datetime","title":"The Problem with Datetime","text":"<p>When performing calculations with extremely small time steps (e.g., in high-frequency signal processing or orbital mechanics), standard datetimes will truncate data.</p> <pre><code>import datetime\nfrom gps_time.core import GPSTime\n\n# A very small time increment (1 nanosecond = 1e-9 seconds)\ndelta_seconds = 1e-9\n\n# START: Datetime\ndt = datetime.datetime(2020, 1, 1, tzinfo=datetime.timezone.utc)\n# Datetime only supports microseconds. 1ns is too small to be registered if added as a float directly\n# or will be lost if converting to/from standard representations that don't support it.\n# Note: datetime arithmetic generally requires timedeltas, resolution is limited.\n\n# START: GPSTime\ngps_t = GPSTime.from_datetime(dt)\ngps_t = gps_t + delta_seconds\n\n# GPSTime preserves the femtoseconds\n# Expected: The time of week should reflect the addition\n# 1ns = 1,000,000 femtoseconds\nprint(f\"Added 1ns. Femtoseconds: {gps_t.femtoseconds}\") \n</code></pre>"},{"location":"advanced_examples/#2-true-physical-intervals-leap-seconds","title":"2. True Physical Intervals (Leap Seconds)","text":"<p>Calculating the duration between two timestamps can be misleading when using UTC because UTC includes discontinuities (leap seconds). <code>GPSTime</code> is a continuous time scale, making it ideal for measuring true physical duration.</p>"},{"location":"advanced_examples/#scenario-the-2016-leap-second","title":"Scenario: The 2016 Leap Second","text":"<p>A positive leap second was inserted at the end of December 31, 2016. - T1: 2016-12-31 23:59:59 UTC - T2: 2017-01-01 00:00:00 UTC</p> <p>In real physical time, 2 seconds elapsed between these two markers (23:59:59 -&gt; 23:59:60 -&gt; 00:00:00). However, standard <code>datetime</code> math (which is ignorant of leap seconds) will say only 1 second elapsed.</p> <pre><code>import datetime\nfrom gps_time.core import GPSTime\nfrom gps_time.leapseconds import utc2gps\n\n# Define the times surrounding the leap second\nt1_utc = datetime.datetime(2016, 12, 31, 23, 59, 59, tzinfo=datetime.timezone.utc)\nt2_utc = datetime.datetime(2017, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc)\n\n# --- Standard Datetime subtraction ---\ndiff_utc = (t2_utc - t1_utc).total_seconds()\nprint(f\"Datetime computed difference: {diff_utc} seconds\") \n# Output: 1.0 (INCORRECT for physical elapsed time)\n\n# --- GPSTime subtraction ---\n# Convert to GPS Time (which accounts for the leap second insertion)\nt1_gps = utc2gps(t1_utc)\nt2_gps = utc2gps(t2_utc)\n\ndiff_gps = t2_gps - t1_gps\nprint(f\"GPSTime computed difference: {diff_gps} seconds\")\n# Output: 2.0 (CORRECT physical elapsed time)\n</code></pre>"},{"location":"advanced_examples/#3-serialization-with-ruamelyaml","title":"3. Serialization with Ruamel.YAML","text":"<p><code>GPSTime</code> objects can be easily serialized to and from YAML using the <code>ruamel.yaml</code> library. This is useful for saving configuration or state that includes precise timestamps.</p> <pre><code>import sys\nfrom ruamel.yaml import YAML\nfrom gps_time.core import GPSTime\n\n# Initialize YAML object\nyaml = YAML()\n# Register the GPSTime class so YAML knows how to represent it\nyaml.register_class(GPSTime)\n\n# Create a GPSTime object\noriginal_time = GPSTime(week_number=2139, seconds=12345.678)\n\n# Serialize to YAML (printed to stdout here, but can be a file)\nprint(\"--- YAML Output ---\")\nyaml.dump(original_time, sys.stdout)\n\n# To save to a file:\n# with open('time.yaml', 'w') as f:\n#     yaml.dump(original_time, f)\n\n# To load from a file:\n# with open('time.yaml', 'r') as f:\n#     loaded_time = yaml.load(f)\n</code></pre>"},{"location":"math_background/","title":"Math and Background","text":"<p>This document explains the mathematical concepts and data representations used in the <code>gps_time</code> library.</p>"},{"location":"math_background/#time-scales","title":"Time Scales","text":""},{"location":"math_background/#gps-time-vs-utc","title":"GPS Time vs. UTC","text":"<p>Global Positioning System (GPS) Time is a continuous time scale that does not include leap seconds. It started on January 6, 1980.</p> <p>Coordinated Universal Time (UTC), however, includes leap seconds to keep the time scale synchronized with the Earth's rotation.</p> <p>The relationship between GPS Time and UTC is:</p> \\[ GPS = UTC + LS \\] <p>Where \\(LS\\) is the number of leap seconds introduced since Jan 6, 1980.</p>"},{"location":"math_background/#code-example-converting-gps-to-utc","title":"Code Example: Converting GPS to UTC","text":"<pre><code>import datetime\nfrom gps_time.core import GPSTime\nfrom gps_time.leapseconds import gps2utc\n\n# GPS Time: Week 2139, 1000.0 seconds\ngps_t = GPSTime(week_number=2139, seconds=1000)\nutc_t = gps2utc(gps_t)\n\nprint(f\"GPS Time: {gps_t}\")\nprint(f\"UTC Time: {utc_t}\")\n</code></pre>"},{"location":"math_background/#data-representation","title":"Data Representation","text":""},{"location":"math_background/#weeks-and-time-of-week-tow","title":"Weeks and Time of Week (TOW)","text":"<p>GPS Time is commonly represented as a \"Week Number\" and \"Seconds of Week\" (Time of Week or TOW).</p> <ul> <li>Week Number: Counts the number of weeks since the epoch (Jan 6, 1980). Note that the broadcast GPS signal uses a 10-bit week number (rolling over every 1024 weeks), but this library typically uses the full (extended) week number.</li> <li>TOW: Seconds since midnight Saturday/Sunday. Range: \\(0 \\le TOW &lt; 604800\\).</li> </ul>"},{"location":"math_background/#code-example-week-rollover","title":"Code Example: Week Rollover","text":"<p>The <code>GPSTime</code> class automatically handles handling seconds that exceed the week duration by incrementing the week number.</p> <pre><code>from gps_time.core import GPSTime\n\n# 604800 seconds is exactly one week\nt = GPSTime(week_number=1000, seconds=604805)\n\n# Should normalize to Week 1001, 5 seconds\nprint(f\"Week: {t.week_number}, Seconds: {t.seconds}\") \n</code></pre>"},{"location":"math_background/#femtosecond-precision","title":"Femtosecond Precision","text":"<p>Standard floating-point numbers (doubles) do not have enough precision to represent nanosecond-level timing when measuring time from an epoch years in the past. To solve this, <code>GPSTime</code> stores:</p> <ol> <li>Week Number (int)</li> <li>Seconds (int)</li> <li>Femtoseconds (int) - \\(10^{-15}\\) seconds.</li> </ol> <p>This allows for extremely high precision without floating-point errors.</p>"},{"location":"math_background/#z-count","title":"Z-Count","text":"<p>The Z-Count is a truncated time representation often used in GPS navigation messages. It represents time in 1.5-second epochs.</p> \\[ ZCount = \\frac{TOW}{1.5} \\] <p>Consequently, one Z-Count unit equals 1.5 seconds.</p>"},{"location":"math_background/#code-example-z-count-conversion","title":"Code Example: Z-Count Conversion","text":"<pre><code>from gps_time.core import GPSTime\n\nt = GPSTime(week_number=2000, seconds=150)\nz = t.to_zcount()\n\nprint(f\"TOW: {t.time_of_week}\")\nprint(f\"Z-Count: {z}\") # Should be 100.0\n</code></pre>"},{"location":"tests/","title":"Testing","text":"<p>The <code>gps_time</code> module includes a comprehensive test suite to ensure accuracy and stability, particularly given the critical nature of time conversions in scientific computing.</p>"},{"location":"tests/#test-structure","title":"Test Structure","text":"<p>Measurements are validated against known constants and official data sources (e.g., IERS for leap seconds).</p> Test File Description <code>test_core.py</code> Validates the <code>GPSTime</code> class, including initialization, arithmetic operations (add/sub), and comparisons. Ensures femtosecond precision is maintained. <code>test_datetime.py</code> Verifies conversions between <code>GPSTime</code>, Python <code>datetime</code> objects, and other time formats. Validates <code>datetime2tow</code> and <code>tow2datetime</code> utilities. <code>test_leapseconds.py</code> Checks the accuracy of leap second data and logic. Includes boundary tests to ensure leap seconds are applied exactly at the transition moment (e.g., June 30, 23:59:60). <code>test_utilities.py</code> Tests helper functions like <code>arange_gpstime</code> and validation routines."},{"location":"tests/#running-tests","title":"Running Tests","text":"<p>Tests are written using <code>pytest</code>. To run the full suite:</p> <pre><code>pytest\n</code></pre>"},{"location":"tests/#coverage","title":"Coverage","text":"<p>The test suite covers: - Core Logic: Initialization of <code>GPSTime</code> from weeks/seconds, datetimes, and YAML. - Arithmetic: Addition and subtraction of seconds, <code>timedelta</code>, and other <code>GPSTime</code> objects. - Comparisons: Equality and inequality operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>). - Leap Seconds: Historical leap second dates and predictive logic for future dates. - Edge Cases: Week rollovers, negative time adjustments, and picosecond-level precision.</p>"},{"location":"api/core/","title":"Core","text":"<p>Copyright 2020 The Aerospace Corporation</p>"},{"location":"api/core/#gps_time.core.GPSTime","title":"<code>GPSTime</code>","text":"<p>Time representation for GPS.</p>"},{"location":"api/core/#gps_time.core.GPSTime--parameters","title":"Parameters","text":"<p>week_number : int     The number of weeks since the start of the GPS epoch, 6 Jan 1980. seconds : int     The number of integer seconds into the week. The zero time is at     midnight on Sunday morning, i.e. betwen Saturday and Sunday. Should     be between 0 and 604800 because otherwise, the week number would be     incorrect. femtoseconds : int     The number of femtoseconds into the week. That is, this is the number     of fractional seconds in the time of week with a scale factor of 1e15.</p> Source code in <code>gps_time/core.py</code> <pre><code>class GPSTime:\n    \"\"\"Time representation for GPS.\n\n    Parameters\n    ----------\n    week_number : int\n        The number of weeks since the start of the GPS epoch, 6 Jan 1980.\n    seconds : int\n        The number of integer seconds into the week. The zero time is at\n        midnight on Sunday morning, i.e. betwen Saturday and Sunday. Should\n        be between 0 and 604800 because otherwise, the week number would be\n        incorrect.\n    femtoseconds : int\n        The number of femtoseconds into the week. That is, this is the number\n        of fractional seconds in the time of week with a scale factor of 1e15.\n    \"\"\"\n\n    \"\"\"\n    Todo\n    ----\n    .. todo:: Create a GPSTimeDelta class to handle adding/subtracting with\n        increase accuracy.\n\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        For various operators if not the selected types are not implemented.\n    ValueError\n        If an incorrect set of input arguments are provided to the constructor\n    \"\"\"\n\n    weeks: int\n    seconds: int\n    femtoseconds: int\n\n    yaml_tag: str = u\"!GPSTime\"\n\n    def __init__(self, week_number: int, *args, **kwargs) -&gt; None:\n        \"\"\"Object constructor.\n\n        This sets the week number and the time of week and ensures that the\n        time of week is a float. It also calls `correct_time()`, which checks\n        to see if the time of week is negative or past the end of the week\n        and adjust the values accordingly.\n\n        This constructor supports many different input arguments. However some\n        sets of input arguments may result in truncation and errors if a\n        `float` is provided when an `int` is expected.\n\n        Parameters\n        ----------\n        week_number : int\n            The number of week\n        *args, **kwargs\n            The time of week in various representations. If positional arguments\n            are used, a single positional argument is interpreted as a time of\n            week (i.e. a float), while two arguments are interpreted as seconds\n            and femtoseconds. In the latter case, the values will be cast as\n            integers, which may result in truncation. Keyword arguments function\n            in much the same way, with \"time_of_week\", \"seconds\", and\n            \"femtoseconds\" being the valid keyword arguments. If only \"seconds\"\n            is given, it will be treated like \"time_of_week\". If no additional\n            arguments are given, the time is assumed to be the start of the week.\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            If invalid arguments are given. Examples include:\n            - Mixed positional and keyword arguments are not supported\n            - More than two arguments are not supported\n            - Keyword arguments \"time_of_week\" and \"femtoseconds\" cannot be\n              used together.\n\n        \"\"\"\n        self.yaml_tag: str = u\"!GPSTime\"\n        if len(args) &gt; 0 and len(kwargs) &gt; 0:\n            raise ValueError(\n                \"GPSTime does not support both positional and keyword arguments.\"\n            )\n\n        self.week_number = int(week_number)\n        if len(args) &gt; 2:  # If more than 3 args (week + 2 times)\n            raise ValueError(\n                \"Only up to three arguments allowed (Week number, seconds, \"\n                \"and femtoseconds)\"\n            )\n        elif len(args) == 2:\n            if isinstance(args[0], float) or isinstance(args[1], float):\n                logger.warning(\n                    \"Two times given, but at least one is a float. Decimal \"\n                    \"values will be truncated\"\n                )\n            self.seconds = int(args[0])\n            self.femtoseconds = int(args[1])\n        elif len(args) == 1:\n            self.time_of_week = args[0]\n        else:\n            if len(kwargs) &gt; 2:\n                raise ValueError(\"Too many arguments\")\n            elif len(kwargs) == 0:\n                logger.warning(\n                    \"No time of week information. Defaulting to start of week\"\n                )\n                self.seconds = 0\n                self.femtoseconds = 0\n\n            elif \"femtoseconds\" in kwargs:\n                if \"time_of_week\" in kwargs:\n                    raise ValueError(\n                        \"\"\"Keyword arguments \"time_of_week\" and \"femtoseconds\"\n                        are incompatible.\"\"\"\n                    )\n                elif \"seconds\" in kwargs:\n                    if isinstance(kwargs[\"seconds\"], float) or isinstance(\n                        kwargs[\"femtoseconds\"], float\n                    ):\n                        logger.warning(\n                            \"Two times given, but at least one is a float. \"\n                            \"Decimal values will be truncated\"\n                        )\n                    self.seconds = int(kwargs[\"seconds\"])\n                    self.femtoseconds = int(kwargs[\"femtoseconds\"])\n                else:\n                    raise ValueError(\n                        \"\"\"Keyword argument \"femtoseconds\" must be\n                        accompanied by \"seconds\".\"\"\"\n                    )\n            elif \"seconds\" in kwargs:\n                logger.warning(\n                    \"seconds given with no femtoseconds. Will be handled \"\n                    \"as time of week\"\n                )\n                self.time_of_week = float(kwargs[\"seconds\"])\n            elif \"time_of_week\" in kwargs:\n                self.time_of_week = float(kwargs[\"time_of_week\"])\n            else:\n                raise ValueError(\"Invalid Keyword arguments\")\n\n        self.correct_time()\n        if self.week_number &lt; 0:\n            logger.warning(\"Week number is less than 0\")\n\n    @property\n    def time_of_week(self) -&gt; float:\n        \"\"\"The time of week as a float.\"\"\"\n        return float(self.seconds + self.femtoseconds * _FEMTO_SEC_TO_SEC)\n\n    @time_of_week.setter\n    def time_of_week(self, time_of_week: float) -&gt; None:\n        \"\"\"A setter for the time of week.\n\n        The method allows the seconds and femtoseconds to be updated using\n        a single float.\n\n        Paremeters\n        ----------\n        time_of_week : float\n            The time of week as a float\n        \"\"\"\n        sec, femtosec = _tow2sec(time_of_week)\n        self.seconds = sec\n        self.femtoseconds = femtosec\n\n    @classmethod\n    def from_yaml(\n        cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n    ) -&gt; GPSTime:\n        \"\"\"YAML Constructor.\n\n        This YAML constructor is used to load a GPSTime from a YAML file. It must be\n        registered with the YAML loader. This is accomplished using\n        ```python3\n        import ruamel.yaml\n        yaml = ruamel.yaml.YAML()\n        yaml.register_class(GPSTime)\n        ```\n\n        This class method is primarily used to add a constructor to an instance of\n        ruamel.yaml. Its functionality as a traditional classmethod is limited.\n\n        .. note:: YAML Module\n            This constructor is meant to be used with ruamel.yaml. It has not been tested\n            with pyyaml (the more common YAML library.)\n\n        \"\"\"\n        nodes = node.value\n        week_number = None\n        seconds = None\n        femtoseconds = None\n        time_of_week = None\n        for i in range(0, len(nodes)):\n            node_name = nodes[i][0].value\n            if node_name == \"week_number\":\n                week_number = constructor.construct_scalar(nodes[i][1])\n            elif node_name == \"seconds\":\n                seconds = constructor.construct_scalar(nodes[i][1])\n            elif node_name == \"femtoseconds\":\n                femtoseconds = constructor.construct_scalar(nodes[i][1])\n            elif node_name == \"time_of_week\":\n                time_of_week = constructor.construct_scalar(nodes[i][1])\n\n        if seconds is None and time_of_week is None:\n            raise ValueError(\"The YAML file lacked both a time_of_week and a seconds\")\n        if seconds is not None and time_of_week is not None:\n            raise ValueError(\n                \"YAML file defines both time_of_week and seconds (incompatible)\"\n            )\n        elif time_of_week is not None and femtoseconds is not None:\n            raise ValueError(\n                \"YAML file defines both time_of_week and femtoseconds (incompatible)\"\n            )\n        elif seconds is not None and femtoseconds is None:\n            seconds, femtoseconds = _tow2sec(float(seconds))\n        elif time_of_week is not None:\n            seconds, femtoseconds = _tow2sec(float(time_of_week))\n\n        return cls(int(week_number), int(seconds), int(femtoseconds))\n\n    def to_datetime(self) -&gt; datetime.datetime:\n        \"\"\"Convert the `GPSTime` to a datetime.\n\n        This method calls `tow2datetime()` to convert the `GPSTime` to a\n        datetime object.\n\n        Returns\n        -------\n        datetime.datetime\n            The equivalent datetime representation of the `GPSTime`\n\n        Notes\n        -----\n        .. note::\n            Datetimes are limited to microsecond resolution, so this\n            conversion may lose some fidelity.\n\n        \"\"\"\n        return tow2datetime(self.week_number, self.time_of_week)\n\n    @classmethod\n    def from_datetime(cls, time: datetime.datetime) -&gt; GPSTime:\n        \"\"\"Create a `GPSTime` for a datetime.\n\n        Parameters\n        ----------\n        time : datetime.datetime\n            The datetime that will be converted to a `GPSTime`\n\n        Returns\n        -------\n        GPSTime\n            The `GPSTime` corresponding to the datetime. This is a lossless\n            conversion.\n        \"\"\" \n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If the input value is not a datetime\n\n        Notes\n        -----\n        This is a classmethod and thus can be called without instantiating the\n        object first.\n\n        \"\"\"\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"time must be a datetime\")\n\n        week_num, tow = datetime2tow(time)\n\n        return cls(week_num, tow)\n\n    def to_zcount(self) -&gt; float:\n        \"\"\"Get the current Z-Count.\n\n        Returns\n        -------\n        float\n            The time of week divided by 1.5\n\n        \"\"\"\n        return self.time_of_week / 1.5\n\n    def correct_weeks(self) -&gt; None:\n        \"\"\"Correct the week number based on the time of week.\n\n        If the time of week is less than 0 or greater than 604800 seconds,\n        then the week number and time of week will be corrected to ensure that\n        the time of week is within the week indicated by the week number.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        logger.warning(\n            \"The correct_weeks() method will be deprecated in a future version. Use the correct_time() method instead.\"\n        )\n        if (self.time_of_week &gt;= _SEC_IN_WEEK) or (self.time_of_week &lt; 0):\n            weeks_to_add = int(self.time_of_week // _SEC_IN_WEEK)\n            new_time_of_week = float(self.time_of_week % _SEC_IN_WEEK)\n\n            self.week_number += weeks_to_add\n            self.time_of_week = new_time_of_week\n        else:\n            pass\n\n    def correct_time(self) -&gt; None:\n        if (self.femtoseconds &gt;= _SEC_TO_FEMTO_SEC) or (self.femtoseconds &lt; 0):\n            seconds_to_add = int(self.femtoseconds // _SEC_TO_FEMTO_SEC)\n            new_femto_sec = int(self.femtoseconds % _SEC_TO_FEMTO_SEC)\n\n            self.seconds += seconds_to_add\n            self.femtoseconds = new_femto_sec\n\n        if (self.seconds &gt;= _SEC_IN_WEEK) or (self.seconds &lt; 0):\n            weeks_to_add = int(self.seconds // _SEC_IN_WEEK)\n            new_sec = int(self.seconds % _SEC_IN_WEEK)\n\n            self.week_number += weeks_to_add\n            self.seconds = new_sec\n\n    def __add__(\n        self,\n        other: Union[\n            int, float, GPSTime, datetime.datetime, datetime.timedelta, np.ndarray\n        ],\n    ) -&gt; Union[GPSTime, np.ndarray]:\n        \"\"\"Addition, apply an offset to a `GPSTime`.\n\n        This is the addition of a `GPSTime` and another object. In this\n        context, addition means moving the clock of the first argument\n        forward by some amount.\n\n        Suppose `a` is a `GPSTime` and the value give for other represents a\n        positive time. The value returned will be a `GPSTime` object that is\n        the amount of time represented by other after `a`.\n\n        Parameters\n        ----------\n        other : Union[int, float, GPSTime, datetime.datetime,\n                      datetime.timedelta, np.ndarray]\n            The other value to add to the `GPSTime`. `int` and `float` values\n            are the number of seconds to add to the `GPSTime`. `GPSTime` and\n            `datetime.timedelta` have explicit unit definitions that are used.\n             If the value is a datetime.datetime, it is converted to a GPSTime\n             before adding.\n\n        Returns\n        -------\n        Union[GPSTime, np.ndarray]\n            The sum of the `GPSTime` and `other`. If other is an np.array,\n            returns the sum for each element\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If other is not a supported type\n\n        Notes\n        -----\n        .. note::\n            Apart from adding of `datetime.timedelta` objects, this\n            functionality does not exist with datetimes.\n\n        .. note::\n            This function can be used to \"add\" a negative amount of time,\n            which can yield different results than subtraction.\n\n        \"\"\"\n        if isinstance(other, bool):\n            raise TypeError(\n                \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n        if isinstance(other, int) or isinstance(other, float):\n            gps_time_to_add = GPSTime(0, float(other))\n        elif isinstance(other, datetime.timedelta):\n            gps_time_to_add = GPSTime(0, other.total_seconds())\n        elif isinstance(other, datetime.datetime):\n            gps_time_to_add = GPSTime.from_datetime(other)\n        elif isinstance(other, GPSTime):\n            gps_time_to_add = other\n        elif isinstance(other, np.ndarray):\n            input = np.array([self])\n            return input + other\n        else:\n            raise TypeError(\n                \"unsupported operand type(s) for +: '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n\n        week_num = self.week_number + gps_time_to_add.week_number\n        seconds = self.seconds + gps_time_to_add.seconds\n        femtoseconds = self.femtoseconds + gps_time_to_add.femtoseconds\n        return GPSTime(week_num, seconds, femtoseconds)\n\n    def __sub__(\n        self,\n        other: Union[\n            int, float, GPSTime, datetime.datetime, datetime.timedelta, np.ndarray\n        ],\n    ) -&gt; Union[GPSTime, float, np.ndarray]:\n        \"\"\"Subtraction.\n\n        This method is used to represent subtraction. Depending on the type of\n        the arguments, it can be used to find the time offset by an amount or\n        the number of seconds between two times.\n\n        Parameters\n        ----------\n        other : Union[int, float, GPSTime, datetime.datetime,\n                      datetime.timedelta, np.ndarray]\n            The other value to subtract from the `GPSTime`. `int` and `float`\n            values are the number of seconds to subtract from the `GPSTime`.\n            `GPSTime` and `datetime.timedelta` have explicit unit definitions\n            that are used. If the value is a datetime.datetime, it is\n            converted to a GPSTime before subtracting.\n\n        Returns\n        -------\n        Union[GPSTime, float, np.ndarray]\n            A float will be return if both values are `GPSTime` objects that\n            represents the number of seconds between the objects. A GPSTime\n            will be returned otherwise and it represents offsetting the time\n            backward by the amount given. If the input is an np.ndarray, then\n            returns the operation for each element\n\n            Notes\n            -----\n            Subtracting a non-`GPSTime` object is equivalent to adding the opposite\n            of its value\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If other is not a supported type\n\n\n        \"\"\"\n        if isinstance(other, bool):\n            raise TypeError(\n                \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n        if isinstance(other, int) or isinstance(other, float):\n            sec_to_sub, femto_to_sub = _tow2sec(float(other))\n\n            return GPSTime(\n                self.week_number,\n                self.seconds - sec_to_sub,\n                self.femtoseconds - femto_to_sub,\n            )\n\n        elif isinstance(other, datetime.timedelta):\n            sec_to_sub, femto_to_sub = _tow2sec(float(other.total_seconds()))\n\n            return GPSTime(\n                self.week_number,\n                self.seconds - sec_to_sub,\n                self.femtoseconds - femto_to_sub,\n            )\n\n        elif isinstance(other, datetime.datetime):\n            other_gpstime = GPSTime.from_datetime(other)\n\n            weeks_diff = self.week_number - other_gpstime.week_number\n            sec_diff = self.seconds - other_gpstime.seconds\n            femto_diff = self.femtoseconds - other_gpstime.femtoseconds\n\n            return float(\n                weeks_diff * _SEC_IN_WEEK + sec_diff + femto_diff * _FEMTO_SEC_TO_SEC\n            )\n\n        elif isinstance(other, GPSTime):\n            weeks_diff = self.week_number - other.week_number\n            sec_diff = self.seconds - other.seconds\n            femto_diff = self.femtoseconds - other.femtoseconds\n\n            return float(\n                weeks_diff * _SEC_IN_WEEK + sec_diff + femto_diff * _FEMTO_SEC_TO_SEC\n            )\n\n        elif isinstance(other, np.ndarray):\n            if other.dtype == object:\n                _type = np.reshape(other, sum([i for i in other.shape]))[0].__class__\n\n                if _type in (self.__class__, datetime.datetime):\n                    input = np.array([self])\n                    return np.array(input - other, dtype=float)\n                elif _type is datetime.timedelta:\n                    input = np.array([self])\n                    return np.array(input - other, dtype=object)\n            elif other.dtype in (\n                int,\n                float,\n            ):\n                input = np.array([self])\n                return np.array(input - other, dtype=object)\n\n        else:\n            raise TypeError(\n                \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n\n    def __lt__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Less Than.\n\n        .. note:: In this context \"less than\" is equivalent to \"before\"\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is before its comparison\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        if isinstance(other, datetime.datetime):\n            other_time = GPSTime.from_datetime(other)\n        elif isinstance(other, GPSTime):\n            other_time = other\n        else:\n            raise TypeError(\n                \"'&lt;' not supported between instances of '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n        return (self - other_time) &lt; 0\n\n    def __gt__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Greater Than.\n\n        .. note:: In this context \"greater than\" is equivalent to \"after\"\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is after its comparison\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        if isinstance(other, datetime.datetime):\n            other_time = GPSTime.from_datetime(other)\n        elif isinstance(other, GPSTime):\n            other_time = other\n        else:\n            raise TypeError(\n                \"'&gt;' not supported between instances of '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n        return (self - other_time) &gt; 0\n\n    def __eq__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Equality.\n\n        .. note:: In this context \"equality\" is equivalent to \"coincident\"\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is the same time as its comparison\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        if isinstance(other, datetime.datetime):\n            other_time = GPSTime.from_datetime(other)\n        elif isinstance(other, GPSTime):\n            other_time = other\n        else:\n            raise TypeError(\n                \"'&gt;' not supported between instances of '{}' and '{}'\".format(\n                    type(self), type(other)\n                )\n            )\n        return (self - other_time) == 0\n\n    def __le__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Less Than or Equals.\n\n        Calls the `__lt__()` and `__eq__()` methods\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is before or at the same time as its\n            comparison object.\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __ge__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Greater Than or Equals.\n\n        Calls the `__gt__()` and `__eq__()` methods\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is after or at the same time as its\n            comparison object.\n        \"\"\"\n\n        \"\"\"        \n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __ne__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n        \"\"\"Comparison: Not Equals.\n\n        Inverts the result of the `__eq__()` method\n\n        Parameters\n        ----------\n        other : Union[GPSTime, datetime.datetime]\n            The object to compare. Datatimes will be converted to `GPSTime`\n\n        Returns\n        -------\n        bool\n            True if the current object is not the same time as its comparison\n        \"\"\"\n\n        \"\"\"\n        Raises\n        ------\n        TypeError\n            If an invalid type\n\n        \"\"\"\n        return not (self.__eq__(other))\n\n    def __hash__(self):\n        \"\"\"Make GPSTime hashable.\"\"\"\n        return hash(str(self.week_number) + str(self.seconds) + str(self.femtoseconds))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Representation of the object.\n\n        Returns\n        -------\n        str\n            The representation of the object\n\n        \"\"\"\n        return \"GPSTime(week_number={}, time_of_week={})\".format(\n            self.week_number, self.time_of_week\n        )\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.time_of_week","title":"<code>time_of_week</code>  <code>property</code> <code>writable</code>","text":"<p>The time of week as a float.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition, apply an offset to a <code>GPSTime</code>.</p> <p>This is the addition of a <code>GPSTime</code> and another object. In this context, addition means moving the clock of the first argument forward by some amount.</p> <p>Suppose <code>a</code> is a <code>GPSTime</code> and the value give for other represents a positive time. The value returned will be a <code>GPSTime</code> object that is the amount of time represented by other after <code>a</code>.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__add__--parameters","title":"Parameters","text":"<p>other : Union[int, float, GPSTime, datetime.datetime,               datetime.timedelta, np.ndarray]     The other value to add to the <code>GPSTime</code>. <code>int</code> and <code>float</code> values     are the number of seconds to add to the <code>GPSTime</code>. <code>GPSTime</code> and     <code>datetime.timedelta</code> have explicit unit definitions that are used.      If the value is a datetime.datetime, it is converted to a GPSTime      before adding.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__add__--returns","title":"Returns","text":"<p>Union[GPSTime, np.ndarray]     The sum of the <code>GPSTime</code> and <code>other</code>. If other is an np.array,     returns the sum for each element</p> Source code in <code>gps_time/core.py</code> <pre><code>def __add__(\n    self,\n    other: Union[\n        int, float, GPSTime, datetime.datetime, datetime.timedelta, np.ndarray\n    ],\n) -&gt; Union[GPSTime, np.ndarray]:\n    \"\"\"Addition, apply an offset to a `GPSTime`.\n\n    This is the addition of a `GPSTime` and another object. In this\n    context, addition means moving the clock of the first argument\n    forward by some amount.\n\n    Suppose `a` is a `GPSTime` and the value give for other represents a\n    positive time. The value returned will be a `GPSTime` object that is\n    the amount of time represented by other after `a`.\n\n    Parameters\n    ----------\n    other : Union[int, float, GPSTime, datetime.datetime,\n                  datetime.timedelta, np.ndarray]\n        The other value to add to the `GPSTime`. `int` and `float` values\n        are the number of seconds to add to the `GPSTime`. `GPSTime` and\n        `datetime.timedelta` have explicit unit definitions that are used.\n         If the value is a datetime.datetime, it is converted to a GPSTime\n         before adding.\n\n    Returns\n    -------\n    Union[GPSTime, np.ndarray]\n        The sum of the `GPSTime` and `other`. If other is an np.array,\n        returns the sum for each element\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If other is not a supported type\n\n    Notes\n    -----\n    .. note::\n        Apart from adding of `datetime.timedelta` objects, this\n        functionality does not exist with datetimes.\n\n    .. note::\n        This function can be used to \"add\" a negative amount of time,\n        which can yield different results than subtraction.\n\n    \"\"\"\n    if isinstance(other, bool):\n        raise TypeError(\n            \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n    if isinstance(other, int) or isinstance(other, float):\n        gps_time_to_add = GPSTime(0, float(other))\n    elif isinstance(other, datetime.timedelta):\n        gps_time_to_add = GPSTime(0, other.total_seconds())\n    elif isinstance(other, datetime.datetime):\n        gps_time_to_add = GPSTime.from_datetime(other)\n    elif isinstance(other, GPSTime):\n        gps_time_to_add = other\n    elif isinstance(other, np.ndarray):\n        input = np.array([self])\n        return input + other\n    else:\n        raise TypeError(\n            \"unsupported operand type(s) for +: '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n\n    week_num = self.week_number + gps_time_to_add.week_number\n    seconds = self.seconds + gps_time_to_add.seconds\n    femtoseconds = self.femtoseconds + gps_time_to_add.femtoseconds\n    return GPSTime(week_num, seconds, femtoseconds)\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Comparison: Equality.</p> <p>.. note:: In this context \"equality\" is equivalent to \"coincident\"</p>"},{"location":"api/core/#gps_time.core.GPSTime.__eq__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__eq__--returns","title":"Returns","text":"<p>bool     True if the current object is the same time as its comparison</p> Source code in <code>gps_time/core.py</code> <pre><code>def __eq__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Equality.\n\n    .. note:: In this context \"equality\" is equivalent to \"coincident\"\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is the same time as its comparison\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    if isinstance(other, datetime.datetime):\n        other_time = GPSTime.from_datetime(other)\n    elif isinstance(other, GPSTime):\n        other_time = other\n    else:\n        raise TypeError(\n            \"'&gt;' not supported between instances of '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n    return (self - other_time) == 0\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Comparison: Greater Than or Equals.</p> <p>Calls the <code>__gt__()</code> and <code>__eq__()</code> methods</p>"},{"location":"api/core/#gps_time.core.GPSTime.__ge__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__ge__--returns","title":"Returns","text":"<p>bool     True if the current object is after or at the same time as its     comparison object.</p> Source code in <code>gps_time/core.py</code> <pre><code>def __ge__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Greater Than or Equals.\n\n    Calls the `__gt__()` and `__eq__()` methods\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is after or at the same time as its\n        comparison object.\n    \"\"\"\n\n    \"\"\"        \n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    return self.__gt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Comparison: Greater Than.</p> <p>.. note:: In this context \"greater than\" is equivalent to \"after\"</p>"},{"location":"api/core/#gps_time.core.GPSTime.__gt__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__gt__--returns","title":"Returns","text":"<p>bool     True if the current object is after its comparison</p> Source code in <code>gps_time/core.py</code> <pre><code>def __gt__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Greater Than.\n\n    .. note:: In this context \"greater than\" is equivalent to \"after\"\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is after its comparison\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    if isinstance(other, datetime.datetime):\n        other_time = GPSTime.from_datetime(other)\n    elif isinstance(other, GPSTime):\n        other_time = other\n    else:\n        raise TypeError(\n            \"'&gt;' not supported between instances of '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n    return (self - other_time) &gt; 0\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__hash__","title":"<code>__hash__()</code>","text":"<p>Make GPSTime hashable.</p> Source code in <code>gps_time/core.py</code> <pre><code>def __hash__(self):\n    \"\"\"Make GPSTime hashable.\"\"\"\n    return hash(str(self.week_number) + str(self.seconds) + str(self.femtoseconds))\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__init__","title":"<code>__init__(week_number, *args, **kwargs)</code>","text":"<p>Object constructor.</p> <p>This sets the week number and the time of week and ensures that the time of week is a float. It also calls <code>correct_time()</code>, which checks to see if the time of week is negative or past the end of the week and adjust the values accordingly.</p> <p>This constructor supports many different input arguments. However some sets of input arguments may result in truncation and errors if a <code>float</code> is provided when an <code>int</code> is expected.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__init__--parameters","title":"Parameters","text":"<p>week_number : int     The number of week args, *kwargs     The time of week in various representations. If positional arguments     are used, a single positional argument is interpreted as a time of     week (i.e. a float), while two arguments are interpreted as seconds     and femtoseconds. In the latter case, the values will be cast as     integers, which may result in truncation. Keyword arguments function     in much the same way, with \"time_of_week\", \"seconds\", and     \"femtoseconds\" being the valid keyword arguments. If only \"seconds\"     is given, it will be treated like \"time_of_week\". If no additional     arguments are given, the time is assumed to be the start of the week.</p> Source code in <code>gps_time/core.py</code> <pre><code>def __init__(self, week_number: int, *args, **kwargs) -&gt; None:\n    \"\"\"Object constructor.\n\n    This sets the week number and the time of week and ensures that the\n    time of week is a float. It also calls `correct_time()`, which checks\n    to see if the time of week is negative or past the end of the week\n    and adjust the values accordingly.\n\n    This constructor supports many different input arguments. However some\n    sets of input arguments may result in truncation and errors if a\n    `float` is provided when an `int` is expected.\n\n    Parameters\n    ----------\n    week_number : int\n        The number of week\n    *args, **kwargs\n        The time of week in various representations. If positional arguments\n        are used, a single positional argument is interpreted as a time of\n        week (i.e. a float), while two arguments are interpreted as seconds\n        and femtoseconds. In the latter case, the values will be cast as\n        integers, which may result in truncation. Keyword arguments function\n        in much the same way, with \"time_of_week\", \"seconds\", and\n        \"femtoseconds\" being the valid keyword arguments. If only \"seconds\"\n        is given, it will be treated like \"time_of_week\". If no additional\n        arguments are given, the time is assumed to be the start of the week.\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    ValueError\n        If invalid arguments are given. Examples include:\n        - Mixed positional and keyword arguments are not supported\n        - More than two arguments are not supported\n        - Keyword arguments \"time_of_week\" and \"femtoseconds\" cannot be\n          used together.\n\n    \"\"\"\n    self.yaml_tag: str = u\"!GPSTime\"\n    if len(args) &gt; 0 and len(kwargs) &gt; 0:\n        raise ValueError(\n            \"GPSTime does not support both positional and keyword arguments.\"\n        )\n\n    self.week_number = int(week_number)\n    if len(args) &gt; 2:  # If more than 3 args (week + 2 times)\n        raise ValueError(\n            \"Only up to three arguments allowed (Week number, seconds, \"\n            \"and femtoseconds)\"\n        )\n    elif len(args) == 2:\n        if isinstance(args[0], float) or isinstance(args[1], float):\n            logger.warning(\n                \"Two times given, but at least one is a float. Decimal \"\n                \"values will be truncated\"\n            )\n        self.seconds = int(args[0])\n        self.femtoseconds = int(args[1])\n    elif len(args) == 1:\n        self.time_of_week = args[0]\n    else:\n        if len(kwargs) &gt; 2:\n            raise ValueError(\"Too many arguments\")\n        elif len(kwargs) == 0:\n            logger.warning(\n                \"No time of week information. Defaulting to start of week\"\n            )\n            self.seconds = 0\n            self.femtoseconds = 0\n\n        elif \"femtoseconds\" in kwargs:\n            if \"time_of_week\" in kwargs:\n                raise ValueError(\n                    \"\"\"Keyword arguments \"time_of_week\" and \"femtoseconds\"\n                    are incompatible.\"\"\"\n                )\n            elif \"seconds\" in kwargs:\n                if isinstance(kwargs[\"seconds\"], float) or isinstance(\n                    kwargs[\"femtoseconds\"], float\n                ):\n                    logger.warning(\n                        \"Two times given, but at least one is a float. \"\n                        \"Decimal values will be truncated\"\n                    )\n                self.seconds = int(kwargs[\"seconds\"])\n                self.femtoseconds = int(kwargs[\"femtoseconds\"])\n            else:\n                raise ValueError(\n                    \"\"\"Keyword argument \"femtoseconds\" must be\n                    accompanied by \"seconds\".\"\"\"\n                )\n        elif \"seconds\" in kwargs:\n            logger.warning(\n                \"seconds given with no femtoseconds. Will be handled \"\n                \"as time of week\"\n            )\n            self.time_of_week = float(kwargs[\"seconds\"])\n        elif \"time_of_week\" in kwargs:\n            self.time_of_week = float(kwargs[\"time_of_week\"])\n        else:\n            raise ValueError(\"Invalid Keyword arguments\")\n\n    self.correct_time()\n    if self.week_number &lt; 0:\n        logger.warning(\"Week number is less than 0\")\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__le__","title":"<code>__le__(other)</code>","text":"<p>Comparison: Less Than or Equals.</p> <p>Calls the <code>__lt__()</code> and <code>__eq__()</code> methods</p>"},{"location":"api/core/#gps_time.core.GPSTime.__le__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__le__--returns","title":"Returns","text":"<p>bool     True if the current object is before or at the same time as its     comparison object.</p> Source code in <code>gps_time/core.py</code> <pre><code>def __le__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Less Than or Equals.\n\n    Calls the `__lt__()` and `__eq__()` methods\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is before or at the same time as its\n        comparison object.\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Comparison: Less Than.</p> <p>.. note:: In this context \"less than\" is equivalent to \"before\"</p>"},{"location":"api/core/#gps_time.core.GPSTime.__lt__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__lt__--returns","title":"Returns","text":"<p>bool     True if the current object is before its comparison</p> Source code in <code>gps_time/core.py</code> <pre><code>def __lt__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Less Than.\n\n    .. note:: In this context \"less than\" is equivalent to \"before\"\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is before its comparison\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    if isinstance(other, datetime.datetime):\n        other_time = GPSTime.from_datetime(other)\n    elif isinstance(other, GPSTime):\n        other_time = other\n    else:\n        raise TypeError(\n            \"'&lt;' not supported between instances of '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n    return (self - other_time) &lt; 0\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Comparison: Not Equals.</p> <p>Inverts the result of the <code>__eq__()</code> method</p>"},{"location":"api/core/#gps_time.core.GPSTime.__ne__--parameters","title":"Parameters","text":"<p>other : Union[GPSTime, datetime.datetime]     The object to compare. Datatimes will be converted to <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.__ne__--returns","title":"Returns","text":"<p>bool     True if the current object is not the same time as its comparison</p> Source code in <code>gps_time/core.py</code> <pre><code>def __ne__(self, other: Union[GPSTime, datetime.datetime]) -&gt; bool:\n    \"\"\"Comparison: Not Equals.\n\n    Inverts the result of the `__eq__()` method\n\n    Parameters\n    ----------\n    other : Union[GPSTime, datetime.datetime]\n        The object to compare. Datatimes will be converted to `GPSTime`\n\n    Returns\n    -------\n    bool\n        True if the current object is not the same time as its comparison\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If an invalid type\n\n    \"\"\"\n    return not (self.__eq__(other))\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__repr__","title":"<code>__repr__()</code>","text":"<p>Representation of the object.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__repr__--returns","title":"Returns","text":"<p>str     The representation of the object</p> Source code in <code>gps_time/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Representation of the object.\n\n    Returns\n    -------\n    str\n        The representation of the object\n\n    \"\"\"\n    return \"GPSTime(week_number={}, time_of_week={})\".format(\n        self.week_number, self.time_of_week\n    )\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction.</p> <p>This method is used to represent subtraction. Depending on the type of the arguments, it can be used to find the time offset by an amount or the number of seconds between two times.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__sub__--parameters","title":"Parameters","text":"<p>other : Union[int, float, GPSTime, datetime.datetime,               datetime.timedelta, np.ndarray]     The other value to subtract from the <code>GPSTime</code>. <code>int</code> and <code>float</code>     values are the number of seconds to subtract from the <code>GPSTime</code>.     <code>GPSTime</code> and <code>datetime.timedelta</code> have explicit unit definitions     that are used. If the value is a datetime.datetime, it is     converted to a GPSTime before subtracting.</p>"},{"location":"api/core/#gps_time.core.GPSTime.__sub__--returns","title":"Returns","text":"<p>Union[GPSTime, float, np.ndarray]     A float will be return if both values are <code>GPSTime</code> objects that     represents the number of seconds between the objects. A GPSTime     will be returned otherwise and it represents offsetting the time     backward by the amount given. If the input is an np.ndarray, then     returns the operation for each element</p> <pre><code>Notes\n-----\nSubtracting a non-`GPSTime` object is equivalent to adding the opposite\nof its value\n</code></pre> Source code in <code>gps_time/core.py</code> <pre><code>def __sub__(\n    self,\n    other: Union[\n        int, float, GPSTime, datetime.datetime, datetime.timedelta, np.ndarray\n    ],\n) -&gt; Union[GPSTime, float, np.ndarray]:\n    \"\"\"Subtraction.\n\n    This method is used to represent subtraction. Depending on the type of\n    the arguments, it can be used to find the time offset by an amount or\n    the number of seconds between two times.\n\n    Parameters\n    ----------\n    other : Union[int, float, GPSTime, datetime.datetime,\n                  datetime.timedelta, np.ndarray]\n        The other value to subtract from the `GPSTime`. `int` and `float`\n        values are the number of seconds to subtract from the `GPSTime`.\n        `GPSTime` and `datetime.timedelta` have explicit unit definitions\n        that are used. If the value is a datetime.datetime, it is\n        converted to a GPSTime before subtracting.\n\n    Returns\n    -------\n    Union[GPSTime, float, np.ndarray]\n        A float will be return if both values are `GPSTime` objects that\n        represents the number of seconds between the objects. A GPSTime\n        will be returned otherwise and it represents offsetting the time\n        backward by the amount given. If the input is an np.ndarray, then\n        returns the operation for each element\n\n        Notes\n        -----\n        Subtracting a non-`GPSTime` object is equivalent to adding the opposite\n        of its value\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If other is not a supported type\n\n\n    \"\"\"\n    if isinstance(other, bool):\n        raise TypeError(\n            \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n    if isinstance(other, int) or isinstance(other, float):\n        sec_to_sub, femto_to_sub = _tow2sec(float(other))\n\n        return GPSTime(\n            self.week_number,\n            self.seconds - sec_to_sub,\n            self.femtoseconds - femto_to_sub,\n        )\n\n    elif isinstance(other, datetime.timedelta):\n        sec_to_sub, femto_to_sub = _tow2sec(float(other.total_seconds()))\n\n        return GPSTime(\n            self.week_number,\n            self.seconds - sec_to_sub,\n            self.femtoseconds - femto_to_sub,\n        )\n\n    elif isinstance(other, datetime.datetime):\n        other_gpstime = GPSTime.from_datetime(other)\n\n        weeks_diff = self.week_number - other_gpstime.week_number\n        sec_diff = self.seconds - other_gpstime.seconds\n        femto_diff = self.femtoseconds - other_gpstime.femtoseconds\n\n        return float(\n            weeks_diff * _SEC_IN_WEEK + sec_diff + femto_diff * _FEMTO_SEC_TO_SEC\n        )\n\n    elif isinstance(other, GPSTime):\n        weeks_diff = self.week_number - other.week_number\n        sec_diff = self.seconds - other.seconds\n        femto_diff = self.femtoseconds - other.femtoseconds\n\n        return float(\n            weeks_diff * _SEC_IN_WEEK + sec_diff + femto_diff * _FEMTO_SEC_TO_SEC\n        )\n\n    elif isinstance(other, np.ndarray):\n        if other.dtype == object:\n            _type = np.reshape(other, sum([i for i in other.shape]))[0].__class__\n\n            if _type in (self.__class__, datetime.datetime):\n                input = np.array([self])\n                return np.array(input - other, dtype=float)\n            elif _type is datetime.timedelta:\n                input = np.array([self])\n                return np.array(input - other, dtype=object)\n        elif other.dtype in (\n            int,\n            float,\n        ):\n            input = np.array([self])\n            return np.array(input - other, dtype=object)\n\n    else:\n        raise TypeError(\n            \"unsupported operand type(s) for -: '{}' and '{}'\".format(\n                type(self), type(other)\n            )\n        )\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.correct_weeks","title":"<code>correct_weeks()</code>","text":"<p>Correct the week number based on the time of week.</p> <p>If the time of week is less than 0 or greater than 604800 seconds, then the week number and time of week will be corrected to ensure that the time of week is within the week indicated by the week number.</p>"},{"location":"api/core/#gps_time.core.GPSTime.correct_weeks--returns","title":"Returns","text":"<p>None</p> Source code in <code>gps_time/core.py</code> <pre><code>def correct_weeks(self) -&gt; None:\n    \"\"\"Correct the week number based on the time of week.\n\n    If the time of week is less than 0 or greater than 604800 seconds,\n    then the week number and time of week will be corrected to ensure that\n    the time of week is within the week indicated by the week number.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    logger.warning(\n        \"The correct_weeks() method will be deprecated in a future version. Use the correct_time() method instead.\"\n    )\n    if (self.time_of_week &gt;= _SEC_IN_WEEK) or (self.time_of_week &lt; 0):\n        weeks_to_add = int(self.time_of_week // _SEC_IN_WEEK)\n        new_time_of_week = float(self.time_of_week % _SEC_IN_WEEK)\n\n        self.week_number += weeks_to_add\n        self.time_of_week = new_time_of_week\n    else:\n        pass\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.from_datetime","title":"<code>from_datetime(time)</code>  <code>classmethod</code>","text":"<p>Create a <code>GPSTime</code> for a datetime.</p>"},{"location":"api/core/#gps_time.core.GPSTime.from_datetime--parameters","title":"Parameters","text":"<p>time : datetime.datetime     The datetime that will be converted to a <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.from_datetime--returns","title":"Returns","text":"<p>GPSTime     The <code>GPSTime</code> corresponding to the datetime. This is a lossless     conversion.</p> Source code in <code>gps_time/core.py</code> <pre><code>@classmethod\ndef from_datetime(cls, time: datetime.datetime) -&gt; GPSTime:\n    \"\"\"Create a `GPSTime` for a datetime.\n\n    Parameters\n    ----------\n    time : datetime.datetime\n        The datetime that will be converted to a `GPSTime`\n\n    Returns\n    -------\n    GPSTime\n        The `GPSTime` corresponding to the datetime. This is a lossless\n        conversion.\n    \"\"\" \n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If the input value is not a datetime\n\n    Notes\n    -----\n    This is a classmethod and thus can be called without instantiating the\n    object first.\n\n    \"\"\"\n    if not isinstance(time, datetime.datetime):\n        raise TypeError(\"time must be a datetime\")\n\n    week_num, tow = datetime2tow(time)\n\n    return cls(week_num, tow)\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.from_yaml","title":"<code>from_yaml(constructor, node)</code>  <code>classmethod</code>","text":"<p>YAML Constructor.</p> <p>This YAML constructor is used to load a GPSTime from a YAML file. It must be registered with the YAML loader. This is accomplished using</p> <pre><code>import ruamel.yaml\nyaml = ruamel.yaml.YAML()\nyaml.register_class(GPSTime)\n</code></pre> <p>This class method is primarily used to add a constructor to an instance of ruamel.yaml. Its functionality as a traditional classmethod is limited.</p> <p>.. note:: YAML Module     This constructor is meant to be used with ruamel.yaml. It has not been tested     with pyyaml (the more common YAML library.)</p> Source code in <code>gps_time/core.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n) -&gt; GPSTime:\n    \"\"\"YAML Constructor.\n\n    This YAML constructor is used to load a GPSTime from a YAML file. It must be\n    registered with the YAML loader. This is accomplished using\n    ```python3\n    import ruamel.yaml\n    yaml = ruamel.yaml.YAML()\n    yaml.register_class(GPSTime)\n    ```\n\n    This class method is primarily used to add a constructor to an instance of\n    ruamel.yaml. Its functionality as a traditional classmethod is limited.\n\n    .. note:: YAML Module\n        This constructor is meant to be used with ruamel.yaml. It has not been tested\n        with pyyaml (the more common YAML library.)\n\n    \"\"\"\n    nodes = node.value\n    week_number = None\n    seconds = None\n    femtoseconds = None\n    time_of_week = None\n    for i in range(0, len(nodes)):\n        node_name = nodes[i][0].value\n        if node_name == \"week_number\":\n            week_number = constructor.construct_scalar(nodes[i][1])\n        elif node_name == \"seconds\":\n            seconds = constructor.construct_scalar(nodes[i][1])\n        elif node_name == \"femtoseconds\":\n            femtoseconds = constructor.construct_scalar(nodes[i][1])\n        elif node_name == \"time_of_week\":\n            time_of_week = constructor.construct_scalar(nodes[i][1])\n\n    if seconds is None and time_of_week is None:\n        raise ValueError(\"The YAML file lacked both a time_of_week and a seconds\")\n    if seconds is not None and time_of_week is not None:\n        raise ValueError(\n            \"YAML file defines both time_of_week and seconds (incompatible)\"\n        )\n    elif time_of_week is not None and femtoseconds is not None:\n        raise ValueError(\n            \"YAML file defines both time_of_week and femtoseconds (incompatible)\"\n        )\n    elif seconds is not None and femtoseconds is None:\n        seconds, femtoseconds = _tow2sec(float(seconds))\n    elif time_of_week is not None:\n        seconds, femtoseconds = _tow2sec(float(time_of_week))\n\n    return cls(int(week_number), int(seconds), int(femtoseconds))\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.to_datetime","title":"<code>to_datetime()</code>","text":"<p>Convert the <code>GPSTime</code> to a datetime.</p> <p>This method calls <code>tow2datetime()</code> to convert the <code>GPSTime</code> to a datetime object.</p>"},{"location":"api/core/#gps_time.core.GPSTime.to_datetime--returns","title":"Returns","text":"<p>datetime.datetime     The equivalent datetime representation of the <code>GPSTime</code></p>"},{"location":"api/core/#gps_time.core.GPSTime.to_datetime--notes","title":"Notes","text":"<p>.. note::     Datetimes are limited to microsecond resolution, so this     conversion may lose some fidelity.</p> Source code in <code>gps_time/core.py</code> <pre><code>def to_datetime(self) -&gt; datetime.datetime:\n    \"\"\"Convert the `GPSTime` to a datetime.\n\n    This method calls `tow2datetime()` to convert the `GPSTime` to a\n    datetime object.\n\n    Returns\n    -------\n    datetime.datetime\n        The equivalent datetime representation of the `GPSTime`\n\n    Notes\n    -----\n    .. note::\n        Datetimes are limited to microsecond resolution, so this\n        conversion may lose some fidelity.\n\n    \"\"\"\n    return tow2datetime(self.week_number, self.time_of_week)\n</code></pre>"},{"location":"api/core/#gps_time.core.GPSTime.to_zcount","title":"<code>to_zcount()</code>","text":"<p>Get the current Z-Count.</p>"},{"location":"api/core/#gps_time.core.GPSTime.to_zcount--returns","title":"Returns","text":"<p>float     The time of week divided by 1.5</p> Source code in <code>gps_time/core.py</code> <pre><code>def to_zcount(self) -&gt; float:\n    \"\"\"Get the current Z-Count.\n\n    Returns\n    -------\n    float\n        The time of week divided by 1.5\n\n    \"\"\"\n    return self.time_of_week / 1.5\n</code></pre>"},{"location":"api/datetime/","title":"Datetime Tools","text":""},{"location":"api/datetime/#gps_time.datetime.__all__","title":"<code>__all__ = ['ISO_FMT', 'cast_to_datetime', 'datetime_to_iso', 'array_time_difference', 'correct_week', 'arange_datetime', 'diff_seconds', 'subtract_timedelta', 'datetime2tow', 'subtract_timedelta_as_tow', 'tow2datetime', 'tow2zcount', 'zcount2tow', 'datetime2zcount', 'zcount2datetime']</code>  <code>module-attribute</code>","text":"<p>Copyright 2020 The Aerospace Corporation</p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime","title":"<code>arange_datetime(start_datetime, duration_s, step_ms)</code>","text":"<p>Create a list of datetimes in sequence.</p> <p>The purpose of this function is to create a list that represents a sequence of datetimes of the specified duration with the specified step size.</p> <p>This function is an analogue of the <code>numpy.arange()</code> function, but operates on datetimes.</p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime--parameters","title":"Parameters","text":"<p>start_gpstime : datetime.datetime     The datetime to start the sequence duration_s : float     The duration of the sequence, in seconds step_ms : float     The step size, in milliseconds</p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime--returns","title":"Returns","text":"<p>List[datetime.datetime]     The sequence of datetime</p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime--notes","title":"Notes","text":"<p>Like <code>numpy.arange</code>, this does not include the final element. That is, if the start is at 0 with a duration of 5 and step of 1, the sequence would return [0, 1, 2, 3, 4]</p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime--see-also","title":"See Also","text":"<p><code>numpy.arange()</code> <code>arange_gpstime()</code></p>"},{"location":"api/datetime/#gps_time.datetime.arange_datetime--todo","title":"Todo","text":"<p>.. todo:: Determine if this still works if a np.ndarray is returned     instead of a list</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def arange_datetime(\n    start_datetime: datetime.datetime, duration_s: float, step_ms: float\n) -&gt; List[datetime.datetime]:\n    \"\"\"Create a list of datetimes in sequence.\n\n    The purpose of this function is to create a list that represents a\n    sequence of datetimes of the specified duration with the specified step\n    size.\n\n    This function is an analogue of the `numpy.arange()` function, but\n    operates on datetimes.\n\n    Parameters\n    ----------\n    start_gpstime : datetime.datetime\n        The datetime to start the sequence\n    duration_s : float\n        The duration of the sequence, in seconds\n    step_ms : float\n        The step size, in milliseconds\n\n    Returns\n    -------\n    List[datetime.datetime]\n        The sequence of datetime\n\n    Notes\n    -----\n    Like `numpy.arange`, this does not include the final element. That is, if\n    the start is at 0 with a duration of 5 and step of 1, the sequence would\n    return [0, 1, 2, 3, 4]\n\n    See Also\n    --------\n    `numpy.arange()`\n    `arange_gpstime()`\n\n    Todo\n    ----\n    .. todo:: Determine if this still works if a np.ndarray is returned\n        instead of a list\n\n    \"\"\"\n    times = []\n    dt = datetime.timedelta(milliseconds=step_ms)\n    duration = datetime.timedelta(seconds=duration_s)\n    end_date = start_datetime + duration\n    while True:\n        date = start_datetime + len(times) * dt\n        if date &lt; end_date:\n            times.append(date)\n        else:\n            break\n    return times\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.array_time_difference","title":"<code>array_time_difference(datetime_array1, datetime_array2)</code>","text":"<p>Get time delta (sec) from arrays of datetime.</p> <p>The purpose of this function is to compute the time between two arrays of datetime objects. If the first argument is \\(T_{1}\\) and the second argument is \\(T_{2}\\), then this function returns \\(T_{1} - T_{2}\\) in seconds. If a single DateTime object is given for one of the arguments, it is converted to a single element numpy array.</p>"},{"location":"api/datetime/#gps_time.datetime.array_time_difference--parameters","title":"Parameters","text":"<p>datetime_array1 : np.ndarray     The first date time array datetime_array2 : np.ndarray     The second date time array</p>"},{"location":"api/datetime/#gps_time.datetime.array_time_difference--returns","title":"Returns","text":"<p>np.ndarray     A NumPy array containing the time from the the second datetime     array to the first</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def array_time_difference(\n    datetime_array1: np.ndarray, datetime_array2: np.ndarray\n) -&gt; np.ndarray:\n    r\"\"\"Get time delta (sec) from arrays of datetime.\n\n    The purpose of this function is to compute the time between two arrays of\n    datetime objects. If the first argument is \\(T_{1}\\) and the second\n    argument is \\(T_{2}\\), then this function returns\n    \\(T_{1} - T_{2}\\) in seconds. If a single DateTime object is given for\n    one of the arguments, it is converted to a single element numpy array.\n\n    Parameters\n    ----------\n    datetime_array1 : np.ndarray\n        The first date time array\n    datetime_array2 : np.ndarray\n        The second date time array\n\n    Returns\n    -------\n    np.ndarray\n        A NumPy array containing the time from the the second datetime\n        array to the first\n\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If the inputs are not arrays of datetimes\n    \"\"\"\n    if isinstance(datetime_array1, datetime.datetime):\n        datetime_array1 = np.array([datetime_array1])\n    if isinstance(datetime_array2, datetime.datetime):\n        datetime_array2 = np.array([datetime_array2])\n\n    if not (\n        isinstance(datetime_array1, np.ndarray)\n        and isinstance(datetime_array2, np.ndarray)\n    ):\n        raise TypeError(\n            \"\"\"Both DateTimeArray1 and DateTimeArray2 must be\n                        NumPy arrays. Use numpy.array() to convert a list to\n                        an NumPy array.\"\"\"\n        )\n\n    if not (all(isinstance(x, datetime.datetime) for x in datetime_array1)):\n        raise TypeError(\"DateTimeArray1 must be an array of DateTime objects\")\n    if not (all(isinstance(x, datetime.datetime) for x in datetime_array2)):\n        raise TypeError(\"DateTimeArray2 must be an array of DateTime objects\")\n\n    time_delta = datetime_array1 - datetime_array2\n\n    return np.array([x.total_seconds() for x in time_delta])\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.cast_to_datetime","title":"<code>cast_to_datetime(iso_string)</code>","text":"<p>Cast an ISO string to a datetime object.</p> <p>Iso format is defined as YYYY-MM-DDTHH:MM:SS.SSSSSS, for this cast the formatters (- : . T) are all optional, technically all thats needed is a 20 digit integer with the values in the right place</p>"},{"location":"api/datetime/#gps_time.datetime.cast_to_datetime--parameters","title":"Parameters","text":"<p>iso_string : str     string to convert to datetime</p>"},{"location":"api/datetime/#gps_time.datetime.cast_to_datetime--returns","title":"Returns","text":"<p>datetime.datetime     The datetime defined by the string</p>"},{"location":"api/datetime/#gps_time.datetime.cast_to_datetime--see-also","title":"See Also","text":"<p><code>ISO_FMT</code></p> Source code in <code>gps_time/datetime.py</code> <pre><code>def cast_to_datetime(iso_string: str) -&gt; datetime.datetime:\n    \"\"\"Cast an ISO string to a datetime object.\n\n    Iso format is defined as YYYY-MM-DDTHH:MM:SS.SSSSSS, for this cast the\n    formatters (- : . T) are all optional, technically all thats needed is\n    a 20 digit integer with the values in the right place\n\n    Parameters\n    ----------\n    iso_string : str\n        string to convert to datetime\n\n    Returns\n    -------\n    datetime.datetime\n        The datetime defined by the string\n\n    See Also\n    --------\n    `ISO_FMT`\n\n    \"\"\"\n\n    \"\"\"    \n    Raises\n    ------\n    IOError\n        If the input does not contain an ISO datetime format\n    \"\"\"\n\n    m = re.match(ISO_FMT, iso_string)\n    if m is not None:\n        y, m, d, h, minute, s, us = [int(v) if v is not None else v for v in m.groups()]\n        if us is None:\n            us = 0\n        return datetime.datetime(year=y, month=m, day=d, hour=h, minute=minute, second=s, microsecond=us, tzinfo=datetime.timezone.utc)\n\n    else:\n        raise IOError(\"Value {} not in ISO Time Format\".format(iso_string))\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.correct_week","title":"<code>correct_week(week_num, tow, year)</code>","text":"<p>Correct the week number for week rollovers.</p> <p>Provide the mod 1024 week number and update to the actual GPS week based on the year</p>"},{"location":"api/datetime/#gps_time.datetime.correct_week--parameters","title":"Parameters","text":"<p>week_num : int     The mod 1024 week number tow : float     The time of week year : int     The year</p>"},{"location":"api/datetime/#gps_time.datetime.correct_week--returns","title":"Returns","text":"<p>int     The full GPS week number</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def correct_week(week_num: int, tow: float, year: int) -&gt; int:\n    \"\"\"Correct the week number for week rollovers.\n\n    Provide the mod 1024 week number and update to the actual GPS week based\n    on the year\n\n    Parameters\n    ----------\n    week_num : int\n        The mod 1024 week number\n    tow : float\n        The time of week\n    year : int\n        The year\n\n    Returns\n    -------\n    int\n        The full GPS week number\n\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    ValueError\n        If the year is not an int\n    ValueError\n        If the week number and year are inconsistent\n    \"\"\"\n    if not isinstance(year, int):\n        raise ValueError(\"The year must be an int\")\n\n    # Get the year for the week number\n    current_year = _gps_epoch_datetime + datetime.timedelta(\n        days=7 * week_num, seconds=tow\n    )\n\n    # While the week number is before the desired year, keep adding 1024\n    # weeks and compare. Note that if a match is found, the while loop\n    # breaks. If it is not, the while loop exits to else, which raises and\n    # error.\n    while current_year.year &lt;= year:\n\n        # Break when the year and year expressed by the week number are the\n        # same.\n        if current_year.year == year:\n            break\n\n        # Add 1024 weeks to the week number and recompute the current year\n        week_num += 1024\n        current_year = _gps_epoch_datetime + datetime.timedelta(\n            days=7 * week_num, seconds=tow\n        )\n    else:  # If the week number is not consistent with the year\n        raise ValueError(\"WeekNum and Year are inconsistent.\")\n\n    return week_num\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.datetime2tow","title":"<code>datetime2tow(date_time)</code>","text":"<p>Convert date time to GPS Week and Time of Week.</p> <p>The purpose of this function is to convert a datetime object to the GPS week number and the time of week. This returns the full GPS week number. The user must separately compute the mod 1024 week if that is desired.</p>"},{"location":"api/datetime/#gps_time.datetime.datetime2tow--parameters","title":"Parameters","text":"<p>date_time : datetime.datetime     A datetime object representing the desired times. If no tzinfo is      provided, assumed to be UTC</p>"},{"location":"api/datetime/#gps_time.datetime.datetime2tow--returns","title":"Returns","text":"<p>Tuple[int, float]     Two elements: 1) The GPS Week Number and 2) the time of week</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def datetime2tow(date_time: datetime.datetime) -&gt; Tuple[int, float]:\n    \"\"\"Convert date time to GPS Week and Time of Week.\n\n    The purpose of this function is to convert a datetime object to the GPS\n    week number and the time of week. This returns the full GPS week number.\n    The user must separately compute the mod 1024 week if that is desired.\n\n    Parameters\n    ----------\n    date_time : datetime.datetime\n        A datetime object representing the desired times. If no tzinfo is \n        provided, assumed to be UTC\n\n    Returns\n    -------\n    Tuple[int, float]\n        Two elements: 1) The GPS Week Number and 2) the time of week\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    TypeError\n        If the input is not a datetime\n    \"\"\"\n\n    # Ensure the argument is a datetime object\n    if not isinstance(date_time, datetime.datetime):\n        raise TypeError(\"DateTime arg must be a datetime object.\")\n\n    if date_time.tzinfo is None:\n        date_time=date_time.replace(tzinfo=datetime.timezone.utc)\n\n    # Find the week number\n    week_num = (date_time - _gps_epoch_datetime).days // 7\n\n    # Determine the first day of the week and compute the time since the start\n    # of the week, in seconds\n    week_start = _gps_epoch_datetime + datetime.timedelta(days=week_num * 7)\n    time_since_week_start = date_time - week_start\n    time_of_week = time_since_week_start.total_seconds()\n\n    # Returns the week number and the time of week\n    return int(week_num), float(time_of_week)\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.datetime2zcount","title":"<code>datetime2zcount(date_time)</code>","text":"<p>Convert a datetime to z-count and week number.</p> <p>This function takes a datetime and returns a week number and z-count. It accomplishes this by first calling datetime2tow() and then tow2zcount().</p>"},{"location":"api/datetime/#gps_time.datetime.datetime2zcount--parameters","title":"Parameters","text":"<p>date_time : datetime.datetime     The datetime</p>"},{"location":"api/datetime/#gps_time.datetime.datetime2zcount--returns","title":"Returns","text":"<p>Tuple[int, float]     The week number and z-count</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def datetime2zcount(date_time: datetime.datetime) -&gt; Tuple[int, float]:\n    \"\"\"Convert a datetime to z-count and week number.\n\n    This function takes a datetime and returns a week number and z-count. It\n    accomplishes this by first calling datetime2tow() and then tow2zcount().\n\n    Parameters\n    ----------\n    date_time : datetime.datetime\n        The datetime\n\n    Returns\n    -------\n    Tuple[int, float]\n        The week number and z-count\n\n    \"\"\"\n    week_num, tow = datetime2tow(date_time)\n    week_num, zcount = tow2zcount(week_num, tow)\n\n    return week_num, zcount\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.datetime_to_iso","title":"<code>datetime_to_iso(date_time)</code>","text":"<p>Convert a datetime to an iso string.</p> <p>The purpose of this function is to convert a datetime object to a string in the standard ISO format.</p>"},{"location":"api/datetime/#gps_time.datetime.datetime_to_iso--parameters","title":"Parameters","text":"<p>date_time : datetime.datetime     A datetime object</p>"},{"location":"api/datetime/#gps_time.datetime.datetime_to_iso--returns","title":"Returns","text":"<p>str     A string containing the ISO formatted time, i.e.     YYYY-MM-DDTHH:MM:SS.SSSSSS</p>"},{"location":"api/datetime/#gps_time.datetime.datetime_to_iso--todo","title":"Todo","text":"<p>.. todo:: Determine Usefulness     This appears to alias the datetime built-in isoformat() function.     Determine if this function should still be included or it provides     additional functionality</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def datetime_to_iso(date_time: datetime.datetime) -&gt; str:\n    \"\"\"Convert a datetime to an iso string.\n\n    The purpose of this function is to convert a datetime object to a string\n    in the standard ISO format.\n\n    Parameters\n    ----------\n    date_time : datetime.datetime\n        A datetime object\n\n    Returns\n    -------\n    str\n        A string containing the ISO formatted time, i.e.\n        YYYY-MM-DDTHH:MM:SS.SSSSSS\n\n    Todo\n    ----\n    .. todo:: Determine Usefulness\n        This appears to alias the datetime built-in isoformat() function.\n        Determine if this function should still be included or it provides\n        additional functionality\n\n    \"\"\"\n    return \"T\".join(str(date_time).split(\" \"))\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.diff_seconds","title":"<code>diff_seconds(dt_obj, dt_array)</code>","text":"<p>Get the time diff in seconds between a single date time and an array.</p> <p>This function is uses to find the time difference between a single datetime and an array of datetimes. It returns the value of the single datetime minus the array of datetimes</p>"},{"location":"api/datetime/#gps_time.datetime.diff_seconds--parameters","title":"Parameters","text":"<p>dt_obj : datetime.datetime     A single datetime object dt_array : Iterable[datetime.datetime]     An array of datetime objects</p>"},{"location":"api/datetime/#gps_time.datetime.diff_seconds--returns","title":"Returns","text":"<p>np.ndarray     An array of time differences between dt_obj and each element of     dt_array</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def diff_seconds(\n    dt_obj: datetime.datetime, dt_array: Iterable[datetime.datetime]\n) -&gt; np.ndarray:\n    \"\"\"Get the time diff in seconds between a single date time and an array.\n\n    This function is uses to find the time difference between a single datetime\n    and an array of datetimes. It returns the value of the single datetime\n    minus the array of datetimes\n\n    Parameters\n    ----------\n    dt_obj : datetime.datetime\n        A single datetime object\n    dt_array : Iterable[datetime.datetime]\n        An array of datetime objects\n\n    Returns\n    -------\n    np.ndarray\n        An array of time differences between dt_obj and each element of\n        dt_array\n\n    \"\"\"\n    return np.array([(dt_obj - dt).total_seconds() for dt in dt_array])\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta","title":"<code>subtract_timedelta(datetime_array, time_delta)</code>","text":"<p>Subtract a time delta from an array of datetimes.</p> <p>This function is used to subtract an array of time deltas in seconds from an array of datetimes.</p>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta--parameters","title":"Parameters","text":"<p>datetime_array : np.ndarray     An array of datetimes time_delta : np.ndarray     An array of timedeltas, in seconds</p>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta--returns","title":"Returns","text":"<p>np.ndarray     An array of datetimes that are the input datetime array with the     time delta subtracted from them</p> <p>.. todo:: Add checks for inputs</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def subtract_timedelta(\n    datetime_array: np.ndarray, time_delta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Subtract a time delta from an array of datetimes.\n\n    This function is used to subtract an array of time deltas in seconds from\n    an array of datetimes.\n\n    Parameters\n    ----------\n    datetime_array : np.ndarray\n        An array of datetimes\n    time_delta : np.ndarray\n        An array of timedeltas, in seconds\n\n    Returns\n    -------\n    np.ndarray\n        An array of datetimes that are the input datetime array with the\n        time delta subtracted from them\n\n    .. todo:: Add checks for inputs\n\n    \"\"\"\n    return datetime_array - np.array(\n        [datetime.timedelta(seconds=s) for s in time_delta]\n    )\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta_as_tow","title":"<code>subtract_timedelta_as_tow(datetime_array, time_delta)</code>","text":"<p>Subtract time delta from an array of datetimes and return as week/TOW.</p> <p>This function is used to subtract an array of time deltas in seconds from an array of datetimes. It does this by calling subtract_timedelta() to get an array of new datetimes then using datetime2tow() to cast the datetimes in terms of week numbers and times of week.</p>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta_as_tow--parameters","title":"Parameters","text":"<p>datetime_array : np.ndarray     An array of datetimes time_delta : np.ndarray     An array of timedeltas, in seconds</p>"},{"location":"api/datetime/#gps_time.datetime.subtract_timedelta_as_tow--returns","title":"Returns","text":"<p>np.ndarray     An array of week numbers and times of weeks that are the input     datetime array with the time delta subtracted from them</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def subtract_timedelta_as_tow(\n    datetime_array: np.ndarray, time_delta: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Subtract time delta from an array of datetimes and return as week/TOW.\n\n    This function is used to subtract an array of time deltas in seconds from\n    an array of datetimes. It does this by calling subtract_timedelta() to get\n    an array of new datetimes then using datetime2tow() to cast the datetimes\n    in terms of week numbers and times of week.\n\n    Parameters\n    ----------\n    datetime_array : np.ndarray\n        An array of datetimes\n    time_delta : np.ndarray\n        An array of timedeltas, in seconds\n\n    Returns\n    -------\n    np.ndarray\n        An array of week numbers and times of weeks that are the input\n        datetime array with the time delta subtracted from them\n\n    \"\"\"\n    d = subtract_timedelta(datetime_array, time_delta)\n    return np.array([datetime2tow(_d) for _d in d])\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.tow2datetime","title":"<code>tow2datetime(week_num, tow, year=None)</code>","text":"<p>Convert GPS Week and Time of Week to datetime.</p> <p>The purpose of this function is to convert a GPS Week number and a time of week into a DateTime object. The week number represents the number of weeks since 6 January 1980 and the time of week is the number of seconds since midnight Sunday night. Note that the GPS week is sometimes expressed as a mod 1024 week. If this is the case, the Year argument can be used to correct for mod 1024 weeks. If the week number is not consistent with the Year, then an error is raised.</p>"},{"location":"api/datetime/#gps_time.datetime.tow2datetime--parameters","title":"Parameters","text":"<p>week_num : int     GPS Week Number (not limited to 1024) tow : float     Time of Week (seconds since midnight Sunday Morning) year : Optional[int], optional     If not None, used to correct the week_num from mod 1024 week to     the actual week number (weeks since 6 Jan 1980), by default None</p>"},{"location":"api/datetime/#gps_time.datetime.tow2datetime--returns","title":"Returns","text":"<p>datetime.datetime     object that represents the current time</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def tow2datetime(\n    week_num: int, tow: float, year: Optional[int] = None\n) -&gt; datetime.datetime:\n    \"\"\"Convert GPS Week and Time of Week to datetime.\n\n    The purpose of this function is to convert a GPS Week number and a time of\n    week into a DateTime object. The week number represents the number of weeks\n    since 6 January 1980 and the time of week is the number of seconds since\n    midnight Sunday night. Note that the GPS week is sometimes expressed as a\n    mod 1024 week. If this is the case, the Year argument can be used to\n    correct for mod 1024 weeks. If the week number is not consistent with the\n    Year, then an error is raised.\n\n    Parameters\n    ----------\n    week_num : int\n        GPS Week Number (not limited to 1024)\n    tow : float\n        Time of Week (seconds since midnight Sunday Morning)\n    year : Optional[int], optional\n        If not None, used to correct the week_num from mod 1024 week to\n        the actual week number (weeks since 6 Jan 1980), by default None\n\n    Returns\n    -------\n    datetime.datetime\n        object that represents the current time\n\n    \"\"\"\n    # Correct the week number if a year is given\n    if year is not None:\n        week_num = correct_week(week_num, tow, year)\n\n    date_time_out = (\n        _gps_epoch_datetime\n        + datetime.timedelta(days=week_num * 7)\n        + datetime.timedelta(seconds=tow)\n    )\n\n    # Return a datetime object that stores the current week\n    return date_time_out\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.tow2zcount","title":"<code>tow2zcount(week_num, tow, year=None)</code>","text":"<p>Convert a week number and time of week into week and zcount.</p> <p>The Z-Count is the time of week in seconds divided by 1.5. This function is used to convert from a time of week and week number to z-count.</p>"},{"location":"api/datetime/#gps_time.datetime.tow2zcount--parameters","title":"Parameters","text":"<p>week_num : int     The week number tow : float     The time of week (seconds) year : Optional[int], optional     If not None, adjusts the week number to account for week roll     overs. Otherwise, is passed through, by default None</p>"},{"location":"api/datetime/#gps_time.datetime.tow2zcount--returns","title":"Returns","text":"<p>Tuple[int, float]     The week number and z-count</p>"},{"location":"api/datetime/#gps_time.datetime.tow2zcount--notes","title":"Notes","text":"<p>This function returns floating point z-count. Use another method to cast as int if required</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def tow2zcount(\n    week_num: int, tow: float, year: Optional[int] = None\n) -&gt; Tuple[int, float]:\n    \"\"\"Convert a week number and time of week into week and zcount.\n\n    The Z-Count is the time of week in seconds divided by 1.5. This function is\n    used to convert from a time of week and week number to z-count.\n\n    Parameters\n    ----------\n    week_num : int\n        The week number\n    tow : float\n        The time of week (seconds)\n    year : Optional[int], optional\n        If not None, adjusts the week number to account for week roll\n        overs. Otherwise, is passed through, by default None\n\n    Returns\n    -------\n    Tuple[int, float]\n        The week number and z-count\n\n    Notes\n    -----\n    This function returns floating point z-count. Use another method to\n    cast as int if required\n\n    \"\"\"\n    # If not None, correct the week number base on the year\n    if year is not None:\n        week_num = correct_week(week_num, tow, year)\n\n    # Z-count is the week number divided by 1.5\n    zcount = tow / 1.5\n\n    return week_num, zcount\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.zcount2datetime","title":"<code>zcount2datetime(week_num, zcount, year=None)</code>","text":"<p>Convert a week number and time of week into a datetime.</p> <p>The Z-Count is the time of week divided by 1.5. This function is used to convert from a z-count and week number to the equivalent datetime. It accomplished this by calling zcount2tow() and then tow2datetime().</p>"},{"location":"api/datetime/#gps_time.datetime.zcount2datetime--parameters","title":"Parameters","text":"<p>week_num : int     The week number zcount : float     The z-count (1.5 sec epochs) year : Optional[int], optional     If not None, adjusts the week number to account for week roll     overs. Otherwise, is passed through, by default None</p>"},{"location":"api/datetime/#gps_time.datetime.zcount2datetime--returns","title":"Returns","text":"<p>datetime.datetime     The datetime representing the zcount</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def zcount2datetime(\n    week_num: int, zcount: float, year: Optional[int] = None\n) -&gt; datetime.datetime:\n    \"\"\"Convert a week number and time of week into a datetime.\n\n    The Z-Count is the time of week divided by 1.5. This function is used to\n    convert from a z-count and week number to the equivalent datetime. It\n    accomplished this by calling zcount2tow() and then tow2datetime().\n\n    Parameters\n    ----------\n    week_num : int\n        The week number\n    zcount : float\n        The z-count (1.5 sec epochs)\n    year : Optional[int], optional\n        If not None, adjusts the week number to account for week roll\n        overs. Otherwise, is passed through, by default None\n\n    Returns\n    -------\n    datetime.datetime\n        The datetime representing the zcount\n\n    \"\"\"\n    week_num, tow = zcount2tow(week_num, zcount, year=year)\n    date_time = tow2datetime(week_num, tow)\n\n    return date_time\n</code></pre>"},{"location":"api/datetime/#gps_time.datetime.zcount2tow","title":"<code>zcount2tow(week_num, zcount, year=None)</code>","text":"<p>Convert a week number and time of week into week and zcount.</p> <p>The Z-Count is the time of week divided by 1.5. This function is used to convert from a z-count and week number to time of week.</p>"},{"location":"api/datetime/#gps_time.datetime.zcount2tow--parameters","title":"Parameters","text":"<p>week_num : int     The week number zcount : float     The z-count (1.5 sec epochs) year : Optional[int], optional     If not None, adjusts the week number to account for week roll     overs. Otherwise, is passed through, by default None</p>"},{"location":"api/datetime/#gps_time.datetime.zcount2tow--returns","title":"Returns","text":"<p>Tuple[int, float]     The week number and time of week</p> Source code in <code>gps_time/datetime.py</code> <pre><code>def zcount2tow(\n    week_num: int, zcount: float, year: Optional[int] = None\n) -&gt; Tuple[int, float]:\n    \"\"\"Convert a week number and time of week into week and zcount.\n\n    The Z-Count is the time of week divided by 1.5. This function is used to\n    convert from a z-count and week number to time of week.\n\n    Parameters\n    ----------\n    week_num : int\n        The week number\n    zcount : float\n        The z-count (1.5 sec epochs)\n    year : Optional[int], optional\n        If not None, adjusts the week number to account for week roll\n        overs. Otherwise, is passed through, by default None\n\n    Returns\n    -------\n    Tuple[int, float]\n        The week number and time of week\n\n    \"\"\"\n    tow = zcount * 1.5\n\n    # If not None, correct the week number base on the year\n    if year is not None:\n        week_num = correct_week(week_num, tow, year)\n\n    return week_num, tow\n</code></pre>"},{"location":"api/leapseconds/","title":"Leap Seconds","text":""},{"location":"api/leapseconds/#gps_time.leapseconds.__all__","title":"<code>__all__ = ['logger', 'LeapSeconds', 'gps2utc', 'utc2gps']</code>  <code>module-attribute</code>","text":"<p>Copyright 2020 The Aerospace Corporation</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds","title":"<code>LeapSeconds</code>","text":"<p>Determine the number of leap seconds.</p> <p>The purpose of this class is to provide a place to store leap second information. It has two methods: one to get the number of leap seconds at a given time and one to get the next leap second.</p> Source code in <code>gps_time/leapseconds.py</code> <pre><code>class LeapSeconds:\n    \"\"\"Determine the number of leap seconds.\n\n    The purpose of this class is to provide a place to store leap second\n    information. It has two methods: one to get the number of leap seconds at\n    a given time and one to get the next leap second.\n\n\n    \"\"\"\n\n    _leap_seconds: List[List[Union[GPSTime, int]]] = [\n        [GPSTime.from_datetime(time=datetime.datetime(year=1981, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 1],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1982, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 2],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1983, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 3],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1985, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 4],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1987, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 5],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1989, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 6],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1990, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 7],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1992, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 8],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1993, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 9],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1994, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 10],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1995, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 11],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1997, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 12],\n        [GPSTime.from_datetime(time=datetime.datetime(year=1998, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 13],\n        [GPSTime.from_datetime(time=datetime.datetime(year=2005, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 14],\n        [GPSTime.from_datetime(time=datetime.datetime(year=2008, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 15],\n        [GPSTime.from_datetime(time=datetime.datetime(year=2012, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 16],\n        [GPSTime.from_datetime(time=datetime.datetime(year=2015, month=6, day=30, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 17],\n        [GPSTime.from_datetime(time=datetime.datetime(year=2016, month=12, day=31, hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)) + 1, 18],\n    ]\n    \"\"\"Table of Leap Seconds, note that the leap second occues at midnight, but before the next day.\"\"\"\n\n    @classmethod\n    def get_leap_seconds(cls, time: GPSTime) -&gt; int:\n        \"\"\"Get the current number of leap seconds.\n\n        Parameters\n        ----------\n        time : GPSTime\n            The time at which to find the number of leap seconds\n\n        Returns\n        -------\n        int\n            The number of leap seconds at time\n\n        \"\"\"\n        if time &gt; datetime.datetime(2025, 12, 31, 23, 59, 59):\n            logger.warning(\n                \"Leap seconds only current through 31 Dec 2025. Any future \"\n                \"leap seconds not included. Update when available.\"\n            )\n\n        if time &lt; cls._leap_seconds[0][0]:\n            return 0\n        else:\n            for _ls in cls._leap_seconds[::-1]:\n                if time &gt;= _ls[0]:\n                    return _ls[1]\n\n    @classmethod\n    def get_next_leap_second(cls, time: GPSTime) -&gt; Optional[Tuple[GPSTime, int]]:\n        \"\"\"Get the next leap second.\n\n        This method is used to compute the next leap second from the given\n        time. If the time is after the most recent leap second update and\n        there is no planned future leap second, this will return a None\n        indicating no planned update.\n\n\n        Parameters\n        ----------\n        time : GPSTime\n            The time for which the next leap second is desired\n\n        Returns\n        -------\n        Optional[Tuple[GPSTime, int]]\n            A tuple containing the GPSTime of the next leap second and the\n            number of leap seconds at that time. If the next leap second from\n            the desired time is not known, than None is returned.\n\n        \"\"\"\n        if time &gt; datetime.datetime(2025, 12, 31, 23, 59, 59):\n            logger.warning(\n                \"Leap seconds only current through 31 Dec 2025. Any future \"\n                \"leap seconds not included. Update when available.\"\n            )\n\n        if time &lt; cls._leap_seconds[0][0]:\n            return cls._leap_seconds[0]\n        elif time &gt; cls._leap_seconds[-1][0]:\n            return None\n        else:\n            for _ls in cls._leap_seconds:\n                if time &lt; _ls[0]:\n                    return _ls\n</code></pre>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_leap_seconds","title":"<code>get_leap_seconds(time)</code>  <code>classmethod</code>","text":"<p>Get the current number of leap seconds.</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_leap_seconds--parameters","title":"Parameters","text":"<p>time : GPSTime     The time at which to find the number of leap seconds</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_leap_seconds--returns","title":"Returns","text":"<p>int     The number of leap seconds at time</p> Source code in <code>gps_time/leapseconds.py</code> <pre><code>@classmethod\ndef get_leap_seconds(cls, time: GPSTime) -&gt; int:\n    \"\"\"Get the current number of leap seconds.\n\n    Parameters\n    ----------\n    time : GPSTime\n        The time at which to find the number of leap seconds\n\n    Returns\n    -------\n    int\n        The number of leap seconds at time\n\n    \"\"\"\n    if time &gt; datetime.datetime(2025, 12, 31, 23, 59, 59):\n        logger.warning(\n            \"Leap seconds only current through 31 Dec 2025. Any future \"\n            \"leap seconds not included. Update when available.\"\n        )\n\n    if time &lt; cls._leap_seconds[0][0]:\n        return 0\n    else:\n        for _ls in cls._leap_seconds[::-1]:\n            if time &gt;= _ls[0]:\n                return _ls[1]\n</code></pre>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_next_leap_second","title":"<code>get_next_leap_second(time)</code>  <code>classmethod</code>","text":"<p>Get the next leap second.</p> <p>This method is used to compute the next leap second from the given time. If the time is after the most recent leap second update and there is no planned future leap second, this will return a None indicating no planned update.</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_next_leap_second--parameters","title":"Parameters","text":"<p>time : GPSTime     The time for which the next leap second is desired</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.LeapSeconds.get_next_leap_second--returns","title":"Returns","text":"<p>Optional[Tuple[GPSTime, int]]     A tuple containing the GPSTime of the next leap second and the     number of leap seconds at that time. If the next leap second from     the desired time is not known, than None is returned.</p> Source code in <code>gps_time/leapseconds.py</code> <pre><code>@classmethod\ndef get_next_leap_second(cls, time: GPSTime) -&gt; Optional[Tuple[GPSTime, int]]:\n    \"\"\"Get the next leap second.\n\n    This method is used to compute the next leap second from the given\n    time. If the time is after the most recent leap second update and\n    there is no planned future leap second, this will return a None\n    indicating no planned update.\n\n\n    Parameters\n    ----------\n    time : GPSTime\n        The time for which the next leap second is desired\n\n    Returns\n    -------\n    Optional[Tuple[GPSTime, int]]\n        A tuple containing the GPSTime of the next leap second and the\n        number of leap seconds at that time. If the next leap second from\n        the desired time is not known, than None is returned.\n\n    \"\"\"\n    if time &gt; datetime.datetime(2025, 12, 31, 23, 59, 59):\n        logger.warning(\n            \"Leap seconds only current through 31 Dec 2025. Any future \"\n            \"leap seconds not included. Update when available.\"\n        )\n\n    if time &lt; cls._leap_seconds[0][0]:\n        return cls._leap_seconds[0]\n    elif time &gt; cls._leap_seconds[-1][0]:\n        return None\n    else:\n        for _ls in cls._leap_seconds:\n            if time &lt; _ls[0]:\n                return _ls\n</code></pre>"},{"location":"api/leapseconds/#gps_time.leapseconds.gps2utc","title":"<code>gps2utc(gps_time)</code>","text":"<p>Convert GPS Time to UTC Time</p> <p>This function adjust the GPS Time using the number of leap seconds to get the UTC time.</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.gps2utc--parameters","title":"Parameters","text":"<p>gps_time : Union[GPSTime, datetime.datetime]     The current GPS Time</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.gps2utc--returns","title":"Returns","text":"<p>datetime.datetime     The UTC Time</p> Source code in <code>gps_time/leapseconds.py</code> <pre><code>def gps2utc(gps_time: Union[GPSTime, datetime.datetime]) -&gt; datetime.datetime:\n    \"\"\"Convert GPS Time to UTC Time\n\n    This function adjust the GPS Time using the number of leap seconds to get\n    the UTC time.\n\n    Parameters\n    ----------\n    gps_time : Union[GPSTime, datetime.datetime]\n        The current GPS Time\n\n    Returns\n    -------\n    datetime.datetime\n        The UTC Time\n\n    \"\"\"\n    if isinstance(gps_time, datetime.datetime):\n        if gps_time.tzinfo is None:\n            gps_time = gps_time.replace(tzinfo=datetime.timezone.utc)\n        gps_time = GPSTime.from_datetime(gps_time)\n\n    assert isinstance(gps_time, GPSTime), \"gps_time must be a GPSTime or datetime\"\n\n    leap_seconds = LeapSeconds.get_leap_seconds(gps_time)\n    utc_time = gps_time - leap_seconds\n\n    return utc_time.to_datetime()\n</code></pre>"},{"location":"api/leapseconds/#gps_time.leapseconds.utc2gps","title":"<code>utc2gps(utc_time)</code>","text":"<p>Convert UTC Time to GPS Time</p> <p>This function adjust the UTC Time using the number of leap seconds to get the GPS time.</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.utc2gps--parameters","title":"Parameters","text":"<p>utc_time : datetime.datetime     The current UTC Time</p>"},{"location":"api/leapseconds/#gps_time.leapseconds.utc2gps--returns","title":"Returns","text":"<p>GPSTime     The GPS Time</p> Source code in <code>gps_time/leapseconds.py</code> <pre><code>def utc2gps(utc_time: datetime.datetime) -&gt; GPSTime:\n    \"\"\"Convert UTC Time to GPS Time\n\n    This function adjust the UTC Time using the number of leap seconds to get\n    the GPS time.\n\n    Parameters\n    ----------\n    utc_time : datetime.datetime\n        The current UTC Time\n\n    Returns\n    -------\n    GPSTime\n        The GPS Time\n\n    \"\"\"\n    assert isinstance(utc_time, datetime.datetime), \"utc_time must be a datetime\"\n\n    if utc_time.tzinfo != datetime.timezone.utc:\n        logger.warning(\"utc2gps() was passed a datetime object not in the UTC time zone. May cause unintended behavior\")\n\n    leap_seconds = LeapSeconds.get_leap_seconds(GPSTime.from_datetime(utc_time))\n    gps_time = GPSTime.from_datetime(utc_time) + leap_seconds\n\n    return gps_time\n</code></pre>"},{"location":"api/logutils/","title":"Logging Utilities","text":""},{"location":"api/logutils/#gps_time.logutils.__all__","title":"<code>__all__ = ['display_distro_statement', 'Colors', 'ThemeField', 'color_text', 'BasicTheme', 'BasicColorTheme', 'AlignedColorFormatter']</code>  <code>module-attribute</code>","text":"<p>Copyright 2020 The Aerospace Corporation</p>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter","title":"<code>AlignedColorFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Logging formatter to display aligned meta data of date with ms time stamp, logger name, line number, and log level.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>class AlignedColorFormatter(logging.Formatter):\n    \"\"\"\n    Logging formatter to display aligned meta data of date with ms time stamp,\n    logger name, line number, and log level.\n    \"\"\"\n\n    width = 24\n    datefmt = \"%I:%M:%S\"\n\n    def __init__(self, theme: BasicTheme) -&gt; None:\n        \"\"\"\n        Creates the formatted text described and applies a theme to the text.\n\n        Parameters\n        ----------\n        theme: BasicTheme\n            Theme derived from basic theme to apply to text\n        \"\"\"\n        super().__init__()\n        self.theme = theme\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"\n        Applies the desired format to a string passed to one of the log messages.\n\n        Parameters\n        ----------\n        record: logging.LogRecord\n            Data structure containing various log parameters.\n\n        Returns\n        -------\n        str\n            String with applied format and theme\n        \"\"\"\n        record.message = record.getMessage()\n        level = color_text(record.levelname, self.theme.level_color[record.levelname])\n        s = \"%s.%03d :: %+50s :: %-4s :: %-19s | %s \" % (\n            self.formatTime(record, AlignedColorFormatter.datefmt),\n            record.msecs,\n            record.name,\n            record.lineno,\n            level,\n            self.theme.prompt[record.levelname],\n        )\n        s += color_text(record.message, self.theme.text_color[record.levelname])\n\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n            if record.exc_text:\n                if s[-1:] != \"\\n\":\n                    s = s + \"\\n\"\n                s = s + record.exc_text\n        return s\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter.__init__","title":"<code>__init__(theme)</code>","text":"<p>Creates the formatted text described and applies a theme to the text.</p>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter.__init__--parameters","title":"Parameters","text":"<p>theme: BasicTheme     Theme derived from basic theme to apply to text</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __init__(self, theme: BasicTheme) -&gt; None:\n    \"\"\"\n    Creates the formatted text described and applies a theme to the text.\n\n    Parameters\n    ----------\n    theme: BasicTheme\n        Theme derived from basic theme to apply to text\n    \"\"\"\n    super().__init__()\n    self.theme = theme\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter.format","title":"<code>format(record)</code>","text":"<p>Applies the desired format to a string passed to one of the log messages.</p>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter.format--parameters","title":"Parameters","text":"<p>record: logging.LogRecord     Data structure containing various log parameters.</p>"},{"location":"api/logutils/#gps_time.logutils.AlignedColorFormatter.format--returns","title":"Returns","text":"<p>str     String with applied format and theme</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"\n    Applies the desired format to a string passed to one of the log messages.\n\n    Parameters\n    ----------\n    record: logging.LogRecord\n        Data structure containing various log parameters.\n\n    Returns\n    -------\n    str\n        String with applied format and theme\n    \"\"\"\n    record.message = record.getMessage()\n    level = color_text(record.levelname, self.theme.level_color[record.levelname])\n    s = \"%s.%03d :: %+50s :: %-4s :: %-19s | %s \" % (\n        self.formatTime(record, AlignedColorFormatter.datefmt),\n        record.msecs,\n        record.name,\n        record.lineno,\n        level,\n        self.theme.prompt[record.levelname],\n    )\n    s += color_text(record.message, self.theme.text_color[record.levelname])\n\n    if record.exc_info:\n        # Cache the traceback text to avoid converting it multiple times\n        # (it's constant anyway)\n        if not record.exc_text:\n            record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n    return s\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicColorTheme","title":"<code>BasicColorTheme</code>","text":"<p>               Bases: <code>BasicTheme</code></p> <p>Theme for basic colored output where the logging level text is the same color as the log message. This class is a good example for how to create new themes by inheriting from the basic theme. The derived themes if any field is not overwritten just stays the same as the default one.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>class BasicColorTheme(BasicTheme):\n    \"\"\"\n    Theme for basic colored output where the logging level text is the same\n    color as the log message. This class is a good example for how to create\n    new themes by inheriting from the basic theme. The derived themes if any\n    field is not overwritten just stays the same as the default one.\n    \"\"\"\n\n    def __init__(self, theme_name=\"color_theme\"):\n        \"\"\"\n        Instantiates the theme.\n\n        Parameters\n        ----------\n        theme_name: str\n            Name of the theme\n\n        Attributes\n        ----------\n        name: str\n             The name of the theme\n        prompt: str\n             First character(s) before the log message\n        tail: str\n             Final characters in the log message\n        level_color: ThemeField\n             The color of the log level text displayed in the message. In this\n             case [green, white, yellow, purple, red] from DEBUG to CRITICAL\n        text_color: ThemeField\n            The color of the text displayed at each logging level. Same\n            colors as level name\n        theme_name\n        \"\"\"\n        super().__init__(theme_name)\n        self.prompt = ThemeField(*([\"&gt;&gt;\"] * 5))\n        self.text_color = ThemeField(\n            DEBUG=Colors.green,\n            INFO=Colors.white,\n            WARNING=Colors.yellow,\n            ERROR=Colors.purple,\n            CRITICAL=Colors.red,\n        )\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicColorTheme.__init__","title":"<code>__init__(theme_name='color_theme')</code>","text":"<p>Instantiates the theme.</p>"},{"location":"api/logutils/#gps_time.logutils.BasicColorTheme.__init__--parameters","title":"Parameters","text":"<p>theme_name: str     Name of the theme</p>"},{"location":"api/logutils/#gps_time.logutils.BasicColorTheme.__init__--attributes","title":"Attributes","text":"<p>name: str      The name of the theme prompt: str      First character(s) before the log message tail: str      Final characters in the log message level_color: ThemeField      The color of the log level text displayed in the message. In this      case [green, white, yellow, purple, red] from DEBUG to CRITICAL text_color: ThemeField     The color of the text displayed at each logging level. Same     colors as level name theme_name</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __init__(self, theme_name=\"color_theme\"):\n    \"\"\"\n    Instantiates the theme.\n\n    Parameters\n    ----------\n    theme_name: str\n        Name of the theme\n\n    Attributes\n    ----------\n    name: str\n         The name of the theme\n    prompt: str\n         First character(s) before the log message\n    tail: str\n         Final characters in the log message\n    level_color: ThemeField\n         The color of the log level text displayed in the message. In this\n         case [green, white, yellow, purple, red] from DEBUG to CRITICAL\n    text_color: ThemeField\n        The color of the text displayed at each logging level. Same\n        colors as level name\n    theme_name\n    \"\"\"\n    super().__init__(theme_name)\n    self.prompt = ThemeField(*([\"&gt;&gt;\"] * 5))\n    self.text_color = ThemeField(\n        DEBUG=Colors.green,\n        INFO=Colors.white,\n        WARNING=Colors.yellow,\n        ERROR=Colors.purple,\n        CRITICAL=Colors.red,\n    )\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme","title":"<code>BasicTheme</code>","text":"<p>               Bases: <code>object</code></p> <p>The base object used in applying themes. A theme is just a collection of ThemeField objects for different portions of the output log. This class is meant to be inherited from for other themes and the desired fields overwritten with new colors.</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme--class-attributes","title":"Class Attributes","text":"<p>Themes     A list of every theme. This allows for themes to be gotten globally.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>class BasicTheme(object):\n    \"\"\"\n    The base object used in applying themes. A theme is just a collection of\n    ThemeField objects for different portions of the output log. This class\n    is meant to be inherited from for other themes and the desired fields\n    overwritten with new colors.\n\n    Class Attributes\n    ----------------\n    Themes\n        A list of every theme. This allows for themes to be gotten globally.\n    \"\"\"\n\n    THEMES = []\n\n    @classmethod\n    def get_theme(cls, name):\n        \"\"\"\n        Everytime a theme is instantiated its name is added to the THEMES\n        class attribute. This name is used to access any theme defined in\n        runtime by a common theme.\n\n        Parameters\n        ----------\n        name: str\n            Name of theme to be indexed\n\n        Returns\n        -------\n        Optional[BasicTheme]\n            Theme corresponding to input name. If no theme by that name exists\n            None is returned.\n        \"\"\"\n        for theme in BasicTheme.THEMES:\n            if theme == name:\n                return theme\n\n    def __init__(self, theme_name: str) -&gt; None:\n        \"\"\"\n        Creates a theme and adds the theme to the THEMES class attribute for\n        later indexing.\n\n        Parameters\n        ----------\n        theme_name: str\n            Name of the theme\n\n        Attributes\n        ----------\n        name: str\n             The name of the theme\n        prompt: str\n             First character(s) before the log message\n        tail: str\n             Final characters in the log message\n        level_color: ThemeField\n             The color of the log level text displayed in the message\n        text_color: ThemeField\n            The color of the text displayed at each logging level\n        \"\"\"\n        # if theme_name in BasicTheme.THEMES:\n        #     raise ValueError(\"Theme {} already exists\".format(theme_name))\n        self.name = theme_name\n        self.prompt = ThemeField(*([\"&gt;&gt;\"] * 5))\n        self.tail = ThemeField(*([\"\"] * 5))\n        self.level_color = ThemeField(\n            DEBUG=Colors.green,\n            INFO=Colors.white,\n            WARNING=Colors.yellow,\n            ERROR=Colors.purple,\n            CRITICAL=Colors.red,\n        )\n        self.text_color = ThemeField(\n            DEBUG=Colors.normal,\n            INFO=Colors.normal,\n            WARNING=Colors.normal,\n            ERROR=Colors.normal,\n            CRITICAL=Colors.normal,\n        )\n        BasicTheme.THEMES.append(self)\n\n    def __eq__(self, other_name: str) -&gt; bool:\n        \"\"\"\n        Compares the name of self to a string and determines if the two\n        are the same using == operator.\n\n        Parameters\n        ----------\n        other_name: str\n            Name of other theme\n\n        Returns\n        -------\n        bool\n            True if self.name is equal to the other name (case-sensitive)\n        \"\"\"\n        return self.name == other_name\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__eq__","title":"<code>__eq__(other_name)</code>","text":"<p>Compares the name of self to a string and determines if the two are the same using == operator.</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__eq__--parameters","title":"Parameters","text":"<p>other_name: str     Name of other theme</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__eq__--returns","title":"Returns","text":"<p>bool     True if self.name is equal to the other name (case-sensitive)</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __eq__(self, other_name: str) -&gt; bool:\n    \"\"\"\n    Compares the name of self to a string and determines if the two\n    are the same using == operator.\n\n    Parameters\n    ----------\n    other_name: str\n        Name of other theme\n\n    Returns\n    -------\n    bool\n        True if self.name is equal to the other name (case-sensitive)\n    \"\"\"\n    return self.name == other_name\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__init__","title":"<code>__init__(theme_name)</code>","text":"<p>Creates a theme and adds the theme to the THEMES class attribute for later indexing.</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__init__--parameters","title":"Parameters","text":"<p>theme_name: str     Name of the theme</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.__init__--attributes","title":"Attributes","text":"<p>name: str      The name of the theme prompt: str      First character(s) before the log message tail: str      Final characters in the log message level_color: ThemeField      The color of the log level text displayed in the message text_color: ThemeField     The color of the text displayed at each logging level</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __init__(self, theme_name: str) -&gt; None:\n    \"\"\"\n    Creates a theme and adds the theme to the THEMES class attribute for\n    later indexing.\n\n    Parameters\n    ----------\n    theme_name: str\n        Name of the theme\n\n    Attributes\n    ----------\n    name: str\n         The name of the theme\n    prompt: str\n         First character(s) before the log message\n    tail: str\n         Final characters in the log message\n    level_color: ThemeField\n         The color of the log level text displayed in the message\n    text_color: ThemeField\n        The color of the text displayed at each logging level\n    \"\"\"\n    # if theme_name in BasicTheme.THEMES:\n    #     raise ValueError(\"Theme {} already exists\".format(theme_name))\n    self.name = theme_name\n    self.prompt = ThemeField(*([\"&gt;&gt;\"] * 5))\n    self.tail = ThemeField(*([\"\"] * 5))\n    self.level_color = ThemeField(\n        DEBUG=Colors.green,\n        INFO=Colors.white,\n        WARNING=Colors.yellow,\n        ERROR=Colors.purple,\n        CRITICAL=Colors.red,\n    )\n    self.text_color = ThemeField(\n        DEBUG=Colors.normal,\n        INFO=Colors.normal,\n        WARNING=Colors.normal,\n        ERROR=Colors.normal,\n        CRITICAL=Colors.normal,\n    )\n    BasicTheme.THEMES.append(self)\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.get_theme","title":"<code>get_theme(name)</code>  <code>classmethod</code>","text":"<p>Everytime a theme is instantiated its name is added to the THEMES class attribute. This name is used to access any theme defined in runtime by a common theme.</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.get_theme--parameters","title":"Parameters","text":"<p>name: str     Name of theme to be indexed</p>"},{"location":"api/logutils/#gps_time.logutils.BasicTheme.get_theme--returns","title":"Returns","text":"<p>Optional[BasicTheme]     Theme corresponding to input name. If no theme by that name exists     None is returned.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>@classmethod\ndef get_theme(cls, name):\n    \"\"\"\n    Everytime a theme is instantiated its name is added to the THEMES\n    class attribute. This name is used to access any theme defined in\n    runtime by a common theme.\n\n    Parameters\n    ----------\n    name: str\n        Name of theme to be indexed\n\n    Returns\n    -------\n    Optional[BasicTheme]\n        Theme corresponding to input name. If no theme by that name exists\n        None is returned.\n    \"\"\"\n    for theme in BasicTheme.THEMES:\n        if theme == name:\n            return theme\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.Colors","title":"<code>Colors</code>","text":"<p>Data structure containing color codes.</p> <p>Data structure containing character codes which change text color of a bash terminal of all following characters.</p>"},{"location":"api/logutils/#gps_time.logutils.Colors--class-attributes","title":"Class Attributes","text":"<p>normal : str     Resets text colors in the terminal to default colors black : str     Sets text color in terminal to black red : str     Sets text color in terminal to red green : str     Sets text color in terminal to green yellow : str     Sets text color in terminal to yellow blue : str     Sets text color in terminal to blue purple : str     Sets text color in terminal to purple cyan : str     Sets text color in terminal to cyan white : str     Sets text color in terminal to white red_highlight : str     Sets text background color to red green_highlight : str     Sets text background color to green yellow_highlight : str     Sets text background color to yellow blue_highlight : str     Sets text background color to blue purple_highlight : str     Sets text background color to purple cyan_highlight : str     Sets text background color to cyan white_highlight : str     Sets text background color to white bold : str     Sets text thickness larger uline : str     Adds an underline to text blink : str     Makes the text blink at 1Hz invert : str     Inverts the background and text colors</p> Source code in <code>gps_time/logutils.py</code> <pre><code>class Colors:\n    \"\"\"Data structure containing color codes.\n\n    Data structure containing character codes which change text color of a\n    bash terminal of all following characters.\n\n    Class Attributes\n    ----------------\n    normal : str\n        Resets text colors in the terminal to default colors\n    black : str\n        Sets text color in terminal to black\n    red : str\n        Sets text color in terminal to red\n    green : str\n        Sets text color in terminal to green\n    yellow : str\n        Sets text color in terminal to yellow\n    blue : str\n        Sets text color in terminal to blue\n    purple : str\n        Sets text color in terminal to purple\n    cyan : str\n        Sets text color in terminal to cyan\n    white : str\n        Sets text color in terminal to white\n    red_highlight : str\n        Sets text background color to red\n    green_highlight : str\n        Sets text background color to green\n    yellow_highlight : str\n        Sets text background color to yellow\n    blue_highlight : str\n        Sets text background color to blue\n    purple_highlight : str\n        Sets text background color to purple\n    cyan_highlight : str\n        Sets text background color to cyan\n    white_highlight : str\n        Sets text background color to white\n    bold : str\n        Sets text thickness larger\n    uline : str\n        Adds an underline to text\n    blink : str\n        Makes the text blink at 1Hz\n    invert : str\n        Inverts the background and text colors\n    \"\"\"\n\n    normal = \"\\033[0m\"\n    black = \"\\033[30m\"\n    red = \"\\033[31m\"\n    green = \"\\033[32m\"\n    yellow = \"\\033[33m\"\n    blue = \"\\033[34m\"\n    purple = \"\\033[35m\"\n    cyan = \"\\033[36m\"\n    white = \"\\033[37m\"\n\n    red_highlight = \"\\033[41m\"\n    green_highlight = \"\\033[42m\"\n    yellow_highlight = \"\\033[43m\"\n    blue_highlight = \"\\033[44m\"\n    purple_highlight = \"\\033[45m\"\n    cyan_highlight = \"\\033[46m\"\n    white_highlight = \"\\033[47m\"\n\n    bold = \"\\033[1m\"\n    uline = \"\\033[4m\"\n    blink = \"\\033[5m\"\n    invert = \"\\033[7m\"\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.ThemeField","title":"<code>ThemeField</code>","text":"<p>               Bases: <code>object</code></p> <p>Various components of a log can have colors edited such as the prompt, message, etc. A message field maps the colors to various log levels and indexed using logging levels.</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField--parameters","title":"Parameters","text":"<p>DEBUG: str     Str color code defined in Colors class for correcsponding log level INFO: str     Str color code defined in Colors class for correcsponding log level WARNING: str     Str color code defined in Colors class for correcsponding log level ERROR: str     Str color code defined in Colors class for correcsponding log level CRITICAL: str     Str color code defined in Colors class for correcsponding log level</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField--examples","title":"Examples","text":"<pre><code>&gt;&gt; field = ThemeField(DEBUG=Colors.green,\n                      INFO=Colors.white,\n                      WARNING=Colors.yellow,\n                      ERROR=Colors.purple,\n                      CRITICAL=Colors.red)\n</code></pre> Source code in <code>gps_time/logutils.py</code> <pre><code>class ThemeField(object):\n    \"\"\"\n    Various components of a log can have colors edited such as the prompt,\n    message, etc. A message field maps the colors to various log levels\n    and indexed using logging levels.\n\n    Parameters\n    ----------\n    DEBUG: str\n        Str color code defined in Colors class for correcsponding log level\n    INFO: str\n        Str color code defined in Colors class for correcsponding log level\n    WARNING: str\n        Str color code defined in Colors class for correcsponding log level\n    ERROR: str\n        Str color code defined in Colors class for correcsponding log level\n    CRITICAL: str\n        Str color code defined in Colors class for correcsponding log level\n\n    Examples\n    --------\n        &gt;&gt; field = ThemeField(DEBUG=Colors.green,\n                              INFO=Colors.white,\n                              WARNING=Colors.yellow,\n                              ERROR=Colors.purple,\n                              CRITICAL=Colors.red)\n    \"\"\"\n\n    def __init__(self, DEBUG, INFO, WARNING, ERROR, CRITICAL):\n        \"\"\"\n        Initializes logging levels to a color\n\n        Parameters\n        ----------\n        DEBUG:\n            Str color code defined in colors class for corresponding log level\n        INFO:\n            Str color code defined in colors class for corresponding log level\n        WARNING:\n            Str color code defined in colors class for corresponding log level\n        ERROR:\n            Str color code defined in colors class for corresponding log level\n        CRITICAL:\n            Str color code defined in colors class for corresponding log level\n        \"\"\"\n        self.DEBUG = DEBUG\n        self.INFO = INFO\n        self.WARNING = WARNING\n        self.ERROR = ERROR\n        self.CRITICAL = CRITICAL\n\n    def __getitem__(self, item: str) -&gt; str:\n        \"\"\"\n        Gets an attribute using [] indexing. In logging formatters record.level\n        is a string which can be used to index this class.\n\n        Parameters\n        ----------\n        item: str\n            Formatter record.level to return value for\n\n        Returns\n        -------\n        str\n            Color code for corresponding log level\n        \"\"\"\n        return getattr(self, item)\n\n    def __setitem__(self, key: str, value: str) -&gt; None:\n        \"\"\"\n        Sets a color value using [] = indexing to change value with Formatter\n        record.level\n\n        Parameters\n        ----------\n        key: str\n            Formatter record.level or string matching attribute name\n        value: str\n            New color code to set the level to\n        \"\"\"\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Gets an attribute using [] indexing. In logging formatters record.level is a string which can be used to index this class.</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__getitem__--parameters","title":"Parameters","text":"<p>item: str     Formatter record.level to return value for</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__getitem__--returns","title":"Returns","text":"<p>str     Color code for corresponding log level</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __getitem__(self, item: str) -&gt; str:\n    \"\"\"\n    Gets an attribute using [] indexing. In logging formatters record.level\n    is a string which can be used to index this class.\n\n    Parameters\n    ----------\n    item: str\n        Formatter record.level to return value for\n\n    Returns\n    -------\n    str\n        Color code for corresponding log level\n    \"\"\"\n    return getattr(self, item)\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__init__","title":"<code>__init__(DEBUG, INFO, WARNING, ERROR, CRITICAL)</code>","text":"<p>Initializes logging levels to a color</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__init__--parameters","title":"Parameters","text":"<p>DEBUG:     Str color code defined in colors class for corresponding log level INFO:     Str color code defined in colors class for corresponding log level WARNING:     Str color code defined in colors class for corresponding log level ERROR:     Str color code defined in colors class for corresponding log level CRITICAL:     Str color code defined in colors class for corresponding log level</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __init__(self, DEBUG, INFO, WARNING, ERROR, CRITICAL):\n    \"\"\"\n    Initializes logging levels to a color\n\n    Parameters\n    ----------\n    DEBUG:\n        Str color code defined in colors class for corresponding log level\n    INFO:\n        Str color code defined in colors class for corresponding log level\n    WARNING:\n        Str color code defined in colors class for corresponding log level\n    ERROR:\n        Str color code defined in colors class for corresponding log level\n    CRITICAL:\n        Str color code defined in colors class for corresponding log level\n    \"\"\"\n    self.DEBUG = DEBUG\n    self.INFO = INFO\n    self.WARNING = WARNING\n    self.ERROR = ERROR\n    self.CRITICAL = CRITICAL\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets a color value using [] = indexing to change value with Formatter record.level</p>"},{"location":"api/logutils/#gps_time.logutils.ThemeField.__setitem__--parameters","title":"Parameters","text":"<p>key: str     Formatter record.level or string matching attribute name value: str     New color code to set the level to</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def __setitem__(self, key: str, value: str) -&gt; None:\n    \"\"\"\n    Sets a color value using [] = indexing to change value with Formatter\n    record.level\n\n    Parameters\n    ----------\n    key: str\n        Formatter record.level or string matching attribute name\n    value: str\n        New color code to set the level to\n    \"\"\"\n    setattr(self, key, value)\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.color_text","title":"<code>color_text(text, *colors)</code>","text":"<p>Applies color to a specific string and appends the color code to set the text to normal. Text can be various colors by adding more args for colors.</p>"},{"location":"api/logutils/#gps_time.logutils.color_text--parameters","title":"Parameters","text":"<p>text: str     String to color colors: Tuple[str]     Any amount of color codes</p>"},{"location":"api/logutils/#gps_time.logutils.color_text--returns","title":"Returns","text":"<p>str     Input string with each color in colors prepended to the string in     order with a Colors.normal trailing.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def color_text(text: str, *colors: str):\n    \"\"\"\n    Applies color to a specific string and appends the color code to set the\n    text to normal. Text can be various colors by adding more args for colors.\n\n    Parameters\n    ----------\n    text: str\n        String to color\n    colors: Tuple[str]\n        Any amount of color codes\n\n    Returns\n    -------\n    str\n        Input string with each color in colors prepended to the string in\n        order with a Colors.normal trailing.\n    \"\"\"\n    color = \"\"\n    for c in colors:\n        color += c\n    if os.name == \"nt\":  # Windows (bleh)\n        return text\n    else:\n        return color + text + Colors.normal\n</code></pre>"},{"location":"api/logutils/#gps_time.logutils.display_distro_statement","title":"<code>display_distro_statement(msg, logger, level='critical')</code>","text":"<p>Display a distro statement</p> <p>The purpose of this method is to produce a distribution statement in the logger messages. This statement is separated by a line before and after and the message is surrounded by asterisks.</p>"},{"location":"api/logutils/#gps_time.logutils.display_distro_statement--parameters","title":"Parameters","text":"<p>msg : str     The distribution statement logger : logging.Logger     The logger that will be used level : str     The logging level. Valid values are 'critical', 'error', 'warning',     'info', and 'debug'. By default 'critical'.</p> Source code in <code>gps_time/logutils.py</code> <pre><code>def display_distro_statement(\n    msg: str, logger: logging.Logger, level: str = \"critical\"\n) -&gt; None:\n    \"\"\"Display a distro statement\n\n    The purpose of this method is to produce a distribution statement in the\n    logger messages. This statement is separated by a line before and after\n    and the message is surrounded by asterisks.\n\n    Parameters\n    ----------\n    msg : str\n        The distribution statement\n    logger : logging.Logger\n        The logger that will be used\n    level : str\n        The logging level. Valid values are 'critical', 'error', 'warning',\n        'info', and 'debug'. By default 'critical'.\n\n    \"\"\"\n    if level.lower() in (\"critical\", \"error\", \"warning\", \"info\", \"debug\"):\n        logger_method = getattr(logger, level.lower())\n    else:\n        raise ValueError(f\"Invalid Logging Level for Distro Statement: {level}\")\n\n    msg_str = \"*** \" + msg + \" ***\"\n\n    logger_method(\" \")\n    logger_method(\"*\" * len(msg_str))\n    logger_method(msg_str)\n    logger_method(\"*\" * len(msg_str))\n    logger_method(\" \")\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":""},{"location":"api/utilities/#gps_time.utilities.__all__","title":"<code>__all__ = ['logger', 'arange_gpstime', 'validate_gps_week']</code>  <code>module-attribute</code>","text":"<p>Copyright 2020 The Aerospace Corporation</p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime","title":"<code>arange_gpstime(start_gpstime, duration_s, step_ms)</code>","text":"<p>Create a list of GPSTimes in sequence.</p> <p>The purpose of this function is to create a list that represents a sequence of GPSTimes of the specified duration with the specified step size.</p> <p>This function is an analogue of the <code>numpy.arange()</code> function, but operates on GPSTimes.</p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime--parameters","title":"Parameters","text":"<p>start_gpstime : GPSTime     The GPSTime to start the sequence duration_s : float     The duration of the sequence, in seconds step_ms : float     The step size, in milliseconds</p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime--returns","title":"Returns","text":"<p>List[GPSTime]     The sequence of GPSTimes</p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime--notes","title":"Notes","text":"<p>Like <code>numpy.arange</code>, this does not include the final element. That is, if the start is at 0 with a duration of 5 and step of 1, the sequence would return [0, 1, 2, 3, 4]</p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime--see-also","title":"See Also","text":"<p><code>numpy.arange()</code> <code>arange_datetime()</code></p>"},{"location":"api/utilities/#gps_time.utilities.arange_gpstime--todo","title":"Todo","text":"<p>.. todo:: Determine if this still works if a np.ndarray is returned     instead of a list</p> Source code in <code>gps_time/utilities.py</code> <pre><code>def arange_gpstime(\n    start_gpstime: GPSTime, duration_s: float, step_ms: float\n) -&gt; List[GPSTime]:\n    \"\"\"Create a list of GPSTimes in sequence.\n\n    The purpose of this function is to create a list that represents a\n    sequence of GPSTimes of the specified duration with the specified step\n    size.\n\n    This function is an analogue of the `numpy.arange()` function, but\n    operates on GPSTimes.\n\n    Parameters\n    ----------\n    start_gpstime : GPSTime\n        The GPSTime to start the sequence\n    duration_s : float\n        The duration of the sequence, in seconds\n    step_ms : float\n        The step size, in milliseconds\n\n    Returns\n    -------\n    List[GPSTime]\n        The sequence of GPSTimes\n\n    Notes\n    -----\n    Like `numpy.arange`, this does not include the final element. That is, if\n    the start is at 0 with a duration of 5 and step of 1, the sequence would\n    return [0, 1, 2, 3, 4]\n\n    See Also\n    --------\n    `numpy.arange()`\n    `arange_datetime()`\n\n    Todo\n    ----\n    .. todo:: Determine if this still works if a np.ndarray is returned\n        instead of a list\n\n    \"\"\"\n    return list(start_gpstime + np.arange(0, duration_s, step_ms / 1000))\n</code></pre>"},{"location":"api/utilities/#gps_time.utilities.validate_gps_week","title":"<code>validate_gps_week(full_week, gps_week)</code>","text":"<p>Validate that the week numbers are consistent.</p> <p>This function validates that the full GPS week number (i.e. the number of weeks since 6 Jan 1980) and the mod-1024 week numbers are consistent. If they are not, it raises an error.</p>"},{"location":"api/utilities/#gps_time.utilities.validate_gps_week--parameters","title":"Parameters","text":"<p>full_week : int     The number of weeks since 6 Jan 1980 gps_week : int     The mod-1024 GPS week</p>"},{"location":"api/utilities/#gps_time.utilities.validate_gps_week--returns","title":"Returns","text":"<p>None</p> Source code in <code>gps_time/utilities.py</code> <pre><code>def validate_gps_week(full_week: int, gps_week: int) -&gt; None:\n    \"\"\"Validate that the week numbers are consistent.\n\n    This function validates that the full GPS week number (i.e. the number of\n    weeks since 6 Jan 1980) and the mod-1024 week numbers are consistent. If\n    they are not, it raises an error.\n\n    Parameters\n    ----------\n    full_week : int\n        The number of weeks since 6 Jan 1980\n    gps_week : int\n        The mod-1024 GPS week\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    \"\"\"\n    Raises\n    ------\n    ValueError\n        If the `full_week` and `gps_week` disagree\n\n    \"\"\"\n    if full_week % 1024 != gps_week:\n        raise ValueError(\n            \"\".join([\"Full GPS Week {} must be mod 1024 of \", \"GPS Week {}\"]).format(\n                full_week, gps_week\n            )\n        )\n</code></pre>"}]}